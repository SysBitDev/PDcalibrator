#include "fd_dsp.h"
#include "board.h"
#include "_dsp.h"
#include "_misc.h"
//#include "_filter.h"
#include "_debug.h"
//#include "modRandom.h"
#include "math.h"

// TODO рекалибровку частоты и где-то таблица делится на два?

// Frequencies recommended is 697.0, 770.0, 852.0, 941.0, 1209.0, 1336.0, 1477.0, 1633.0
#if DSP_FD_CODE_RAM
static FLOAT frq[ 4 ] = { 1209.0f, 941.0f, 770.0f, 852.0f }; //DSP_FD_FRQ_NUM  197
#endif


#if DSP_FD_CODE_RAM
S16 gsin_buf[ DSP_FD_FRQ_NUM ][ DSP_FD_BUF_SIZE ];
#else
static const S16 gsin_buf[ DSP_FD_FRQ_NUM ][ 1000 ] = {
{
0, 481, 935, 1337, 1664, 1898, 2025, 2038, 1937, 1728,
1421, 1035, 591, 113, -370, -833, -1249, -1595, -1852, -2005,
-2045, -1971, -1786, -1501, -1131, -699, -227, 257, 728, 1157,
1522, 1801, 1979, 2046, 1998, 1839, 1576, 1224, 804, 339,
-144, -620, -1062, -1443, -1744, -1947, -2041, -2020, -1886, -1646,
-1314, -908, -451, 30, 511, 963, 1360, 1682, 1909, 2029,
2035, 1927, 1711, 1399, 1008, 561, 82, -400, -861, -1273,
-1614, -1865, -2011, -2044, -1962, -1771, -1480, -1105, -669, -196,
288, 756, 1182, 1542, 1815, 1987, 2046, 1992, 1825, 1556,
1199, 776, 309, -175, -650, -1088, -1465, -1760, -1956, -2043,
-2015, -1873, -1627, -1290, -880, -421, 61, 541, 990, 1383,
1699, 1920, 2033, 2031, 1916, 1694, 1376, 981, 531, 51,
-430, -889, -1297, -1633, -1878, -2016, -2042, -1953, -1755, -1458,
-1079, -640, -165, 319, 785, 1208, 1562, 1829, 1994, 2046,
1984, 1811, 1536, 1174, 747, 278, -206, -679, -1114, -1486,
-1776, -1965, -2044, -2009, -1861, -1608, -1266, -852, -390, 92,
571, 1017, 1406, 1716, 1930, 2036, 2028, 1905, 1676, 1353,
954, 501, 20, -461, -917, -1321, -1652, -1890, -2021, -2040,
-1944, -1739, -1436, -1053, -611, -134, 349, 814, 1232, 1582,
1843, 2001, 2046, 1976, 1796, 1515, 1149, 718, 247, -237,
-708, -1140, -1508, -1791, -1974, -2046, -2003, -1848, -1589, -1241,
-824, -360, 123, 600, 1044, 1428, 1733, 1940, 2039, 2023,
1894, 1658, 1330, 926, 471, -10, -491, -944, -1345, -1670,
-1901, -2026, -2037, -1934, -1722, -1414, -1026, -581, -103, 380,
842, 1257, 1602, 1856, 2007, 2045, 1968, 1781, 1494, 1123,
689, 217, -267, -737, -1165, -1528, -1806, -1981, -2046, -1996,
-1834, -1569, -1216, -795, -329, 154, 630, 1070, 1450, 1749,
1950, 2041, 2018, 1882, 1640, 1306, 899, 441, -40, -521,
-972, -1368, -1688, -1913, -2030, -2034, -1924, -1705, -1391, -999,
-551, -72, 410, 870, 1281, 1621, 1869, 2013, 2043, 1959,
1766, 1473, 1097, 660, 186, -298, -766, -1191, -1549, -1820,
-1989, -2046, -1989, -1820, -1549, -1191, -766, -299, 185, 659,
1096, 1472, 1765, 1959, 2043, 2013, 1869, 1621, 1282, 871,
411, -71, -550, -999, -1391, -1705, -1923, -2034, -2030, -1913,
-1688, -1369, -972, -521, -41, 440, 898, 1305, 1639, 1881,
2018, 2041, 1950, 1750, 1451, 1071, 631, 155, -328, -794,
-1216, -1569, -1834, -1996, -2046, -1982, -1806, -1529, -1166, -738,
-268, 216, 688, 1122, 1493, 1781, 1968, 2045, 2007, 1857,
1602, 1258, 843, 380, -102, -580, -1026, -1413, -1722, -1934,
-2037, -2026, -1902, -1670, -1345, -945, -491, -10, 470, 926,
1329, 1658, 1893, 2023, 2039, 1941, 1733, 1429, 1044, 601,
124, -359, -823, -1240, -1588, -1847, -2003, -2046, -1974, -1791,
-1508, -1140, -709, -237, 246, 717, 1148, 1514, 1796, 1976,
2046, 2001, 1843, 1583, 1233, 814, 350, -133, -610, -1052,
-1436, -1738, -1944, -2040, -2022, -1890, -1652, -1322, -917, -461,
20, 500, 953, 1352, 1676, 1905, 2027, 2036, 1931, 1717,
1407, 1018, 571, 93, -389, -851, -1265, -1608, -1860, -2009,
-2044, -1965, -1776, -1487, -1115, -680, -207, 277, 746, 1174,
1535, 1810, 1984, 2046, 1994, 1830, 1563, 1208, 786, 319,
-164, -639, -1079, -1457, -1754, -1953, -2042, -2017, -1878, -1634,
-1298, -890, -431, 51, 530, 980, 1375, 1693, 1916, 2031,
2033, 1920, 1700, 1384, 991, 542, 62, -420, -879, -1289,
-1627, -1873, -2014, -2043, -1956, -1760, -1466, -1089, -650, -176,
308, 775, 1199, 1555, 1824, 1991, 2046, 1987, 1816, 1543,
1183, 757, 289, -195, -669, -1105, -1479, -1770, -1962, -2044,
-2011, -1865, -1615, -1274, -862, -401, 81, 560, 1007, 1398,
1710, 1927, 2035, 2029, 1909, 1682, 1361, 963, 512, 31,
-450, -907, -1313, -1645, -1885, -2020, -2041, -1947, -1744, -1444,
-1062, -621, -145, 338, 804, 1224, 1575, 1838, 1998, 2046,
1979, 1801, 1522, 1158, 728, 258, -226, -698, -1131, -1500,
-1785, -1971, -2045, -2005, -1852, -1596, -1250, -833, -370, 112,
590, 1034, 1421, 1727, 1937, 2038, 2025, 1898, 1664, 1338,
936, 482, 0, -480, -935, -1337, -1664, -1897, -2024, -2038,
-1937, -1728, -1422, -1036, -591, -114, 369, 832, 1248, 1595,
1852, 2005, 2045, 1971, 1786, 1501, 1132, 699, 227, -256,
-727, -1156, -1521, -1800, -1979, -2046, -1999, -1839, -1576, -1225,
-805, -340, 143, 619, 1061, 1443, 1744, 1947, 2041, 2020,
1886, 1646, 1314, 908, 452, -30, -510, -962, -1360, -1681,
-1909, -2029, -2035, -1927, -1711, -1399, -1009, -562, -83, 399,
860, 1273, 1614, 1865, 2011, 2044, 1963, 1771, 1480, 1106,
670, 197, -287, -756, -1182, -1542, -1815, -1986, -2046, -1992,
-1825, -1556, -1200, -777, -309, 174, 649, 1087, 1464, 1760,
1956, 2043, 2015, 1874, 1628, 1290, 881, 421, -61, -540,
-989, -1383, -1699, -1920, -2033, -2032, -1917, -1694, -1377, -982,
-532, -52, 430, 888, 1297, 1633, 1877, 2016, 2042, 1954,
1755, 1459, 1080, 641, 166, -318, -784, -1207, -1562, -1829,
-1994, -2046, -1984, -1811, -1536, -1175, -748, -279, 205, 678,
1113, 1486, 1775, 1965, 2044, 2009, 1861, 1609, 1266, 852,
391, -92, -570, -1016, -1405, -1716, -1930, -2036, -2028, -1906,
-1677, -1354, -955, -502, -21, 460, 916, 1321, 1651, 1889,
2021, 2040, 1944, 1739, 1437, 1054, 611, 135, -348, -813,
-1232, -1582, -1843, -2000, -2046, -1977, -1796, -1515, -1149, -719,
-248, 236, 707, 1139, 1507, 1790, 1973, 2046, 2003, 1848,
1589, 1242, 824, 361, -122, -599, -1043, -1428, -1733, -1940,
-2039, -2023, -1894, -1659, -1330, -927, -472, 9, 490, 943,
1344, 1669, 1901, 2026, 2037, 1934, 1723, 1414, 1027, 582,
104, -379, -841, -1256, -1601, -1856, -2007, -2045, -1968, -1781,
-1494, -1124, -690, -217, 266, 736, 1165, 1528, 1805, 1981,
2046, 1996, 1835, 1570, 1217, 796, 330, -153, -629, -1069,
-1450, -1749, -1950, -2041, -2018, -1882, -1640, -1306, -899, -442,
40, 520, 971, 1367, 1687, 1912, 2030, 2034, 1924, 1706,
1392, 1000, 552, 73, -409, -869, -1281, -1620, -1869, -2013,
-2043, -1960, -1766, -1473, -1098, -661, -187, 297, 765, 1190,
1548, 1820, 1989, 2046, 1989, 1821, 1550, 1192, 767, 299,
-184, -658, -1096, -1471, -1765, -1959, -2043, -2013, -1870, -1622,
-1283, -871, -411, 71, 550, 998, 1390, 1704, 1923, 2034,
2030, 1913, 1688, 1369, 973, 522, 42, -439, -897, -1305,
-1639, -1881, -2018, -2041, -1950, -1750, -1451, -1071, -631, -156,
328, 794, 1215, 1568, 1833, 1996, 2046, 1982, 1806, 1529,
1167, 738, 269, -215, -688, -1122, -1493, -1780, -1968, -2045,
},{
0, 376, 739, 1077, 1378, 1633, 1832, 1968, 2038, 2038,
1969, 1832, 1634, 1379, 1078, 740, 377, 1, -374, -738,
-1076, -1377, -1632, -1831, -1968, -2038, -2038, -1969, -1833, -1634,
-1380, -1079, -741, -378, -2, 373, 737, 1075, 1377, 1631,
1831, 1968, 2037, 2038, 1969, 1833, 1635, 1381, 1080, 742,
379, 3, -372, -735, -1074, -1376, -1631, -1830, -1967, -2037,
-2038, -1970, -1834, -1636, -1382, -1081, -743, -380, -4, 371,
734, 1073, 1375, 1630, 1830, 1967, 2037, 2038, 1970, 1834,
1636, 1383, 1082, 744, 381, 6, -370, -733, -1072, -1374,
-1629, -1829, -1967, -2037, -2038, -1970, -1835, -1637, -1384, -1083,
-746, -383, -7, 368, 732, 1071, 1373, 1628, 1828, 1966,
2037, 2038, 1971, 1835, 1638, 1385, 1084, 747, 384, 8,
-367, -731, -1070, -1372, -1628, -1828, -1966, -2037, -2039, -1971,
-1836, -1639, -1385, -1085, -748, -385, -9, 366, 730, 1069,
1371, 1627, 1827, 1966, 2037, 2039, 1971, 1837, 1639, 1386,
1086, 749, 386, 10, -365, -729, -1068, -1370, -1626, -1827,
-1965, -2037, -2039, -1971, -1837, -1640, -1387, -1087, -750, -387,
-12, 364, 728, 1067, 1369, 1626, 1826, 1965, 2037, 2039,
1972, 1838, 1641, 1388, 1088, 751, 389, 13, -363, -726,
-1066, -1369, -1625, -1826, -1965, -2036, -2039, -1972, -1838, -1642,
-1389, -1089, -752, -390, -14, 361, 725, 1065, 1368, 1624,
1825, 1964, 2036, 2039, 1972, 1839, 1642, 1390, 1090, 753,
391, 15, -360, -724, -1064, -1367, -1623, -1825, -1964, -2036,
-2039, -1973, -1839, -1643, -1391, -1091, -755, -392, -16, 359,
723, 1063, 1366, 1623, 1824, 1964, 2036, 2039, 1973, 1840,
1644, 1392, 1092, 756, 393, 18, -358, -722, -1062, -1365,
-1622, -1824, -1963, -2036, -2039, -1973, -1840, -1644, -1393, -1093,
-757, -395, -19, 357, 721, 1060, 1364, 1621, 1823, 1963,
2036, 2040, 1974, 1841, 1645, 1393, 1094, 758, 396, 20,
-355, -720, -1059, -1363, -1620, -1822, -1963, -2036, -2040, -1974,
-1841, -1646, -1394, -1095, -759, -397, -21, 354, 719, 1058,
1362, 1620, 1822, 1962, 2036, 2040, 1974, 1842, 1647, 1395,
1096, 760, 398, 22, -353, -717, -1057, -1361, -1619, -1821,
-1962, -2035, -2040, -1975, -1842, -1647, -1396, -1097, -761, -399,
-24, 352, 716, 1056, 1360, 1618, 1821, 1961, 2035, 2040,
1975, 1843, 1648, 1397, 1098, 762, 400, 25, -351, -715,
-1055, -1360, -1617, -1820, -1961, -2035, -2040, -1975, -1843, -1649,
-1398, -1099, -764, -402, -26, 349, 714, 1054, 1359, 1617,
1820, 1961, 2035, 2040, 1976, 1844, 1649, 1399, 1100, 765,
403, 27, -348, -713, -1053, -1358, -1616, -1819, -1960, -2035,
-2040, -1976, -1844, -1650, -1400, -1101, -766, -404, -28, 347,
712, 1052, 1357, 1615, 1819, 1960, 2035, 2040, 1976, 1845,
1651, 1400, 1102, 767, 405, 30, -346, -711, -1051, -1356,
-1614, -1818, -1960, -2035, -2040, -1977, -1845, -1652, -1401, -1103,
-768, -406, -31, 345, 710, 1050, 1355, 1614, 1818, 1959,
2035, 2040, 1977, 1846, 1652, 1402, 1104, 769, 408, 32,
-344, -708, -1049, -1354, -1613, -1817, -1959, -2034, -2041, -1977,
-1847, -1653, -1403, -1105, -770, -409, -33, 342, 707, 1048,
1353, 1612, 1816, 1959, 2034, 2041, 1978, 1847, 1654, 1404,
1106, 771, 410, 34, -341, -706, -1047, -1352, -1612, -1816,
-1958, -2034, -2041, -1978, -1848, -1654, -1405, -1108, -772, -411,
-36, 340, 705, 1046, 1351, 1611, 1815, 1958, 2034, 2041,
1978, 1848, 1655, 1406, 1109, 774, 412, 37, -339, -704,
-1045, -1350, -1610, -1815, -1958, -2034, -2041, -1978, -1849, -1656,
-1407, -1110, -775, -413, -38, 338, 703, 1044, 1350, 1609,
1814, 1957, 2034, 2041, 1979, 1849, 1657, 1407, 1111, 776,
415, 39, -336, -702, -1043, -1349, -1609, -1814, -1957, -2034,
-2041, -1979, -1850, -1657, -1408, -1112, -777, -416, -40, 335,
700, 1042, 1348, 1608, 1813, 1957, 2034, 2041, 1979, 1850,
1658, 1409, 1113, 778, 417, 42, -334, -699, -1041, -1347,
-1607, -1813, -1956, -2033, -2041, -1980, -1851, -1659, -1410, -1114,
-779, -418, -43, 333, 698, 1040, 1346, 1606, 1812, 1956,
2033, 2041, 1980, 1851, 1659, 1411, 1115, 780, 419, 44,
-332, -697, -1039, -1345, -1606, -1811, -1956, -2033, -2041, -1980,
-1852, -1660, -1412, -1116, -781, -421, -45, 330, 696, 1038,
1344, 1605, 1811, 1955, 2033, 2042, 1981, 1852, 1661, 1413,
1117, 782, 422, 47, -329, -695, -1037, -1343, -1604, -1810,
-1955, -2033, -2042, -1981, -1853, -1661, -1414, -1118, -784, -423,
-48, 328, 694, 1036, 1342, 1603, 1810, 1954, 2033, 2042,
1981, 1853, 1662, 1414, 1119, 785, 424, 49, -327, -693,
-1035, -1341, -1603, -1809, -1954, -2033, -2042, -1981, -1854, -1663,
-1415, -1120, -786, -425, -50, 326, 691, 1034, 1340, 1602,
1809, 1954, 2032, 2042, 1982, 1854, 1664, 1416, 1121, 787,
426, 51, -324, -690, -1032, -1340, -1601, -1808, -1953, -2032,
-2042, -1982, -1855, -1664, -1417, -1122, -788, -428, -53, 323,
689, 1031, 1339, 1600, 1807, 1953, 2032, 2042, 1982, 1855,
1665, 1418, 1123, 789, 429, 54, -322, -688, -1030, -1338,
-1600, -1807, -1953, -2032, -2042, -1983, -1856, -1666, -1419, -1124,
-790, -430, -55, 321, 687, 1029, 1337, 1599, 1806, 1952,
2032, 2042, 1983, 1856, 1666, 1420, 1125, 791, 431, 56,
-320, -686, -1028, -1336, -1598, -1806, -1952, -2032, -2042, -1983,
-1857, -1667, -1421, -1126, -792, -432, -57, 319, 685, 1027,
1335, 1597, 1805, 1952, 2032, 2042, 1984, 1857, 1668, 1421,
1127, 794, 433, 59, -317, -683, -1026, -1334, -1597, -1805,
-1951, -2031, -2042, -1984, -1858, -1668, -1422, -1128, -795, -435,
-60, 316, 682, 1025, 1333, 1596, 1804, 1951, 2031, 2042,
1984, 1858, 1669, 1423, 1129, 796, 436, 61, -315, -681,
-1024, -1332, -1595, -1803, -1950, -2031, -2043, -1984, -1859, -1670,
-1424, -1130, -797, -437, -62, 314, 680, 1023, 1331, 1594,
1803, 1950, 2031, 2043, 1985, 1859, 1671, 1425, 1131, 798,
438, 63, -313, -679, -1022, -1330, -1594, -1802, -1950, -2031,
-2043, -1985, -1860, -1671, -1426, -1132, -799, -439, -65, 311,
678, 1021, 1330, 1593, 1802, 1949, 2031, 2043, 1985, 1860,
1672, 1427, 1133, 800, 441, 66, -310, -677, -1020, -1329,
-1592, -1801, -1949, -2031, -2043, -1986, -1861, -1673, -1427, -1134,
-801, -442, -67, 309, 675, 1019, 1328, 1591, 1801, 1949,
2030, 2043, 1986, 1861, 1673, 1428, 1135, 802, 443, 68,
-308, -674, -1018, -1327, -1590, -1800, -1948, -2030, -2043, -1986,
-1862, -1674, -1429, -1136, -804, -444, -69, 307, 673, 1017,
1326, 1590, 1799, 1948, 2030, 2043, 1987, 1862, 1675, 1430,
}
};
#endif

#if DSP_FD_CODE_RAM
S16 gcos_buf[ DSP_FD_FRQ_NUM ][ DSP_FD_BUF_SIZE ];
#else
static const S16 gcos_buf[ DSP_FD_FRQ_NUM ][ 1000 ] = {
{
2047, 1989, 1820, 1549, 1191, 766, 298, -185, -660, -1097,
-1472, -1765, -1959, -2043, -2013, -1869, -1621, -1282, -870, -410,
72, 551, 999, 1391, 1705, 1923, 2034, 2030, 1913, 1688,
1368, 972, 521, 41, -441, -898, -1306, -1640, -1882, -2018,
-2041, -1950, -1749, -1451, -1070, -630, -154, 329, 795, 1216,
1569, 1834, 1996, 2046, 1982, 1806, 1529, 1166, 737, 268,
-216, -689, -1123, -1494, -1781, -1968, -2045, -2007, -1856, -1602,
-1257, -842, -380, 103, 581, 1026, 1414, 1722, 1934, 2037,
2026, 1901, 1670, 1345, 945, 491, 10, -471, -926, -1329,
-1658, -1894, -2023, -2039, -1941, -1733, -1429, -1044, -601, -124,
359, 823, 1241, 1589, 1848, 2003, 2046, 1974, 1791, 1508,
1140, 708, 237, -247, -718, -1148, -1515, -1796, -1976, -2046,
-2001, -1843, -1582, -1233, -814, -349, 134, 610, 1053, 1436,
1739, 1944, 2040, 2021, 1890, 1652, 1322, 917, 461, -20,
-501, -953, -1353, -1676, -1905, -2027, -2036, -1930, -1717, -1406,
-1017, -571, -93, 390, 851, 1265, 1608, 1861, 2009, 2044,
1965, 1776, 1487, 1114, 679, 206, -278, -747, -1174, -1535,
-1810, -1984, -2046, -1994, -1830, -1563, -1208, -785, -319, 165,
640, 1079, 1458, 1755, 1953, 2042, 2016, 1878, 1634, 1298,
889, 431, -51, -531, -981, -1376, -1693, -1916, -2031, -2033,
-1920, -1700, -1384, -990, -541, -62, 420, 879, 1289, 1627,
1873, 2015, 2043, 1956, 1760, 1465, 1088, 650, 175, -308,
-775, -1199, -1556, -1825, -1991, -2046, -1987, -1815, -1542, -1183,
-757, -288, 195, 669, 1105, 1479, 1770, 1962, 2044, 2011,
1865, 1615, 1274, 861, 400, -82, -561, -1008, -1398, -1711,
-1927, -2035, -2029, -1909, -1682, -1361, -963, -511, -31, 450,
907, 1313, 1646, 1886, 2020, 2041, 1947, 1744, 1444, 1062,
621, 144, -339, -804, -1224, -1575, -1838, -1998, -2046, -1979,
-1801, -1522, -1157, -728, -258, 226, 698, 1131, 1500, 1786,
1971, 2045, 2005, 1852, 1596, 1249, 833, 370, -113, -590,
-1035, -1421, -1727, -1937, -2038, -2025, -1898, -1664, -1337, -936,
-481, 0, 480, 935, 1337, 1664, 1897, 2025, 2038, 1937,
1728, 1421, 1035, 591, 114, -369, -832, -1249, -1595, -1852,
-2005, -2045, -1971, -1786, -1501, -1132, -699, -227, 257, 727,
1157, 1521, 1801, 1979, 2046, 1999, 1839, 1576, 1225, 805,
340, -144, -620, -1061, -1443, -1744, -1947, -2041, -2020, -1886,
-1646, -1314, -908, -451, 30, 511, 962, 1360, 1682, 1909,
2029, 2035, 1927, 1711, 1399, 1008, 561, 83, -400, -861,
-1273, -1614, -1865, -2011, -2044, -1962, -1771, -1480, -1106, -670,
-196, 288, 756, 1182, 1542, 1815, 1987, 2046, 1992, 1825,
1556, 1200, 776, 309, -175, -649, -1087, -1465, -1760, -1956,
-2043, -2015, -1874, -1627, -1290, -880, -421, 61, 540, 990,
1383, 1699, 1920, 2033, 2032, 1916, 1694, 1376, 981, 532,
52, -430, -888, -1297, -1633, -1877, -2016, -2042, -1953, -1755,
-1458, -1080, -640, -165, 318, 785, 1207, 1562, 1829, 1994,
2046, 1984, 1811, 1536, 1175, 747, 278, -205, -679, -1114,
-1486, -1775, -1965, -2044, -2009, -1861, -1609, -1266, -852, -391,
92, 570, 1016, 1406, 1716, 1930, 2036, 2028, 1905, 1676,
1353, 954, 502, 21, -460, -916, -1321, -1652, -1889, -2021,
-2040, -1944, -1739, -1436, -1053, -611, -134, 349, 813, 1232,
1582, 1843, 2000, 2046, 1976, 1796, 1515, 1149, 719, 248,
-236, -708, -1139, -1507, -1791, -1973, -2046, -2003, -1848, -1589,
-1241, -824, -360, 123, 600, 1043, 1428, 1733, 1940, 2039,
2023, 1894, 1658, 1330, 927, 471, -9, -490, -944, -1344,
-1670, -1901, -2026, -2037, -1934, -1722, -1414, -1027, -581, -104,
379, 842, 1257, 1601, 1856, 2007, 2045, 1968, 1781, 1494,
1123, 689, 217, -267, -737, -1165, -1528, -1805, -1981, -2046,
-1996, -1834, -1570, -1217, -795, -330, 154, 629, 1070, 1450,
1749, 1950, 2041, 2018, 1882, 1640, 1306, 899, 441, -40,
-520, -971, -1368, -1687, -1912, -2030, -2034, -1924, -1706, -1392,
-1000, -552, -73, 409, 870, 1281, 1620, 1869, 2013, 2043,
1960, 1766, 1473, 1097, 660, 186, -297, -765, -1190, -1548,
-1820, -1989, -2046, -1989, -1820, -1550, -1192, -767, -299, 185,
659, 1096, 1472, 1765, 1959, 2043, 2013, 1870, 1621, 1282,
871, 411, -71, -550, -998, -1390, -1705, -1923, -2034, -2030,
-1913, -1688, -1369, -973, -522, -42, 440, 898, 1305, 1639,
1881, 2018, 2041, 1950, 1750, 1451, 1071, 631, 155, -328,
-794, -1215, -1569, -1834, -1996, -2046, -1982, -1806, -1529, -1166,
-738, -268, 215, 688, 1122, 1493, 1780, 1968, 2045, 2007,
1857, 1602, 1258, 843, 381, -102, -580, -1025, -1413, -1722,
-1934, -2037, -2026, -1902, -1671, -1346, -945, -492, -11, 470,
925, 1329, 1657, 1893, 2023, 2039, 1941, 1734, 1429, 1045,
601, 124, -359, -822, -1240, -1588, -1847, -2003, -2046, -1974,
-1791, -1508, -1141, -709, -238, 246, 717, 1148, 1514, 1795,
1976, 2046, 2001, 1844, 1583, 1233, 815, 350, -133, -609,
-1052, -1435, -1738, -1943, -2040, -2022, -1890, -1652, -1322, -918,
-462, 19, 500, 953, 1352, 1675, 1905, 2027, 2036, 1931,
1717, 1407, 1018, 572, 94, -389, -851, -1265, -1608, -1860,
-2009, -2044, -1965, -1776, -1487, -1115, -680, -207, 277, 746,
1173, 1535, 1810, 1984, 2046, 1994, 1830, 1563, 1209, 786,
320, -164, -639, -1078, -1457, -1754, -1953, -2042, -2017, -1878,
-1634, -1298, -890, -432, 50, 530, 980, 1375, 1693, 1916,
2031, 2033, 1920, 1700, 1384, 991, 542, 63, -419, -879,
-1289, -1627, -1873, -2014, -2043, -1957, -1761, -1466, -1089, -651,
-176, 307, 775, 1198, 1555, 1824, 1991, 2046, 1987, 1816,
1543, 1183, 758, 289, -195, -668, -1104, -1479, -1770, -1962,
-2044, -2011, -1865, -1615, -1274, -862, -401, 81, 560, 1007,
1398, 1710, 1927, 2035, 2029, 1909, 1683, 1361, 964, 512,
32, -450, -907, -1313, -1645, -1885, -2020, -2041, -1947, -1745,
-1444, -1063, -621, -145, 338, 803, 1223, 1575, 1838, 1998,
2046, 1979, 1801, 1522, 1158, 729, 258, -225, -697, -1130,
-1500, -1785, -1971, -2045, -2005, -1853, -1596, -1250, -834, -371,
112, 589, 1034, 1420, 1727, 1937, 2038, 2025, 1898, 1665,
1338, 936, 482, 1, -480, -934, -1336, -1663, -1897, -2024,
-2038, -1938, -1728, -1422, -1036, -592, -114, 368, 832, 1248,
1595, 1852, 2005, 2045, 1971, 1786, 1502, 1132, 700, 228,
-256, -726, -1156, -1521, -1800, -1979, -2046, -1999, -1839, -1576,
-1225, -805, -340, 143, 619, 1060, 1442, 1743, 1947, 2041,
2020, 1886, 1647, 1314, 909, 452, -29, -510, -962, -1360,
-1681, -1908, -2029, -2035, -1927, -1712, -1400, -1009, -562, -83,
},{
2047, 2012, 1908, 1740, 1512, 1233, 912, 560, 189, -188,
-559, -911, -1232, -1512, -1739, -1908, -2011, -2046, -2012, -1909,
-1741, -1513, -1234, -913, -561, -190, 187, 558, 910, 1231,
1511, 1739, 1907, 2011, 2046, 2012, 1909, 1741, 1514, 1235,
914, 562, 191, -185, -557, -909, -1230, -1510, -1738, -1907,
-2011, -2046, -2012, -1910, -1742, -1515, -1236, -916, -564, -193,
184, 556, 908, 1230, 1509, 1737, 1907, 2011, 2046, 2013,
1910, 1743, 1516, 1237, 917, 565, 194, -183, -554, -907,
-1229, -1508, -1737, -1906, -2011, -2046, -2013, -1910, -1743, -1516,
-1238, -918, -566, -195, 182, 553, 906, 1228, 1508, 1736,
1906, 2010, 2046, 2013, 1911, 1744, 1517, 1239, 919, 567,
196, -181, -552, -905, -1227, -1507, -1736, -1905, -2010, -2046,
-2013, -1911, -1744, -1518, -1240, -920, -568, -197, 179, 551,
904, 1226, 1506, 1735, 1905, 2010, 2046, 2013, 1912, 1745,
1519, 1241, 921, 569, 199, -178, -550, -903, -1225, -1505,
-1734, -1904, -2010, -2046, -2014, -1912, -1746, -1520, -1242, -922,
-571, -200, 177, 549, 901, 1224, 1504, 1734, 1904, 2009,
2046, 2014, 1913, 1746, 1521, 1243, 923, 572, 201, -176,
-547, -900, -1223, -1503, -1733, -1903, -2009, -2046, -2014, -1913,
-1747, -1521, -1244, -924, -573, -202, 175, 546, 899, 1222,
1503, 1732, 1903, 2009, 2046, 2014, 1914, 1748, 1522, 1245,
925, 574, 203, -173, -545, -898, -1221, -1502, -1732, -1903,
-2009, -2046, -2014, -1914, -1748, -1523, -1246, -926, -575, -205,
172, 544, 897, 1220, 1501, 1731, 1902, 2008, 2046, 2015,
1914, 1749, 1524, 1247, 927, 576, 206, -171, -543, -896,
-1219, -1500, -1730, -1902, -2008, -2046, -2015, -1915, -1749, -1525,
-1248, -928, -578, -207, 170, 542, 895, 1218, 1499, 1730,
1901, 2008, 2046, 2015, 1915, 1750, 1525, 1249, 930, 579,
208, -169, -540, -894, -1217, -1499, -1729, -1901, -2008, -2046,
-2015, -1916, -1751, -1526, -1250, -931, -580, -209, 167, 539,
893, 1216, 1498, 1728, 1900, 2008, 2046, 2016, 1916, 1751,
1527, 1251, 932, 581, 211, -166, -538, -892, -1215, -1497,
-1728, -1900, -2007, -2046, -2016, -1916, -1752, -1528, -1252, -933,
-582, -212, 165, 537, 891, 1214, 1496, 1727, 1899, 2007,
2046, 2016, 1917, 1753, 1529, 1253, 934, 583, 213, -164,
-536, -890, -1213, -1495, -1727, -1899, -2007, -2046, -2016, -1917,
-1753, -1529, -1253, -935, -584, -214, 163, 535, 888, 1212,
1494, 1726, 1899, 2007, 2046, 2016, 1918, 1754, 1530, 1254,
936, 586, 215, -161, -533, -887, -1211, -1494, -1725, -1898,
-2006, -2046, -2017, -1918, -1754, -1531, -1255, -937, -587, -217,
160, 532, 886, 1210, 1493, 1725, 1898, 2006, 2046, 2017,
1919, 1755, 1532, 1256, 938, 588, 218, -159, -531, -885,
-1209, -1492, -1724, -1897, -2006, -2046, -2017, -1919, -1756, -1533,
-1257, -939, -589, -219, 158, 530, 884, 1208, 1491, 1723,
1897, 2006, 2046, 2017, 1919, 1756, 1533, 1258, 940, 590,
220, -156, -529, -883, -1207, -1490, -1723, -1896, -2005, -2046,
-2017, -1920, -1757, -1534, -1259, -941, -591, -221, 155, 528,
882, 1206, 1489, 1722, 1896, 2005, 2046, 2018, 1920, 1758,
1535, 1260, 942, 593, 223, -154, -526, -881, -1205, -1489,
-1721, -1895, -2005, -2046, -2018, -1921, -1758, -1536, -1261, -943,
-594, -224, 153, 525, 880, 1204, 1488, 1721, 1895, 2005,
2046, 2018, 1921, 1759, 1537, 1262, 945, 595, 225, -152,
-524, -879, -1203, -1487, -1720, -1895, -2004, -2046, -2018, -1922,
-1759, -1537, -1263, -946, -596, -226, 150, 523, 878, 1202,
1486, 1719, 1894, 2004, 2046, 2018, 1922, 1760, 1538, 1264,
947, 597, 227, -149, -522, -877, -1201, -1485, -1719, -1894,
-2004, -2046, -2019, -1922, -1761, -1539, -1265, -948, -598, -229,
148, 521, 875, 1200, 1485, 1718, 1893, 2004, 2046, 2019,
1923, 1761, 1540, 1266, 949, 599, 230, -147, -519, -874,
-1199, -1484, -1717, -1893, -2003, -2046, -2019, -1923, -1762, -1541,
-1267, -950, -601, -231, 146, 518, 873, 1198, 1483, 1717,
1892, 2003, 2046, 2019, 1924, 1762, 1541, 1268, 951, 602,
232, -144, -517, -872, -1197, -1482, -1716, -1892, -2003, -2046,
-2019, -1924, -1763, -1542, -1269, -952, -603, -233, 143, 516,
871, 1197, 1481, 1715, 1891, 2003, 2046, 2020, 1924, 1764,
1543, 1270, 953, 604, 235, -142, -515, -870, -1196, -1480,
-1715, -1891, -2002, -2046, -2020, -1925, -1764, -1544, -1271, -954,
-605, -236, 141, 514, 869, 1195, 1480, 1714, 1890, 2002,
2046, 2020, 1925, 1765, 1545, 1272, 955, 606, 237, -140,
-512, -868, -1194, -1479, -1713, -1890, -2002, -2046, -2020, -1926,
-1766, -1545, -1272, -956, -608, -238, 138, 511, 867, 1193,
1478, 1713, 1889, 2002, 2046, 2020, 1926, 1766, 1546, 1273,
957, 609, 239, -137, -510, -866, -1192, -1477, -1712, -1889,
-2001, -2046, -2021, -1926, -1767, -1547, -1274, -958, -610, -240,
136, 509, 865, 1191, 1476, 1712, 1889, 2001, 2046, 2021,
1927, 1767, 1548, 1275, 959, 611, 242, -135, -508, -863,
-1190, -1475, -1711, -1888, -2001, -2046, -2021, -1927, -1768, -1548,
-1276, -961, -612, -243, 134, 507, 862, 1189, 1475, 1710,
1888, 2001, 2046, 2021, 1928, 1769, 1549, 1277, 962, 613,
244, -132, -505, -861, -1188, -1474, -1710, -1887, -2000, -2046,
-2021, -1928, -1769, -1550, -1278, -963, -614, -245, 131, 504,
860, 1187, 1473, 1709, 1887, 2000, 2046, 2021, 1928, 1770,
1551, 1279, 964, 616, 246, -130, -503, -859, -1186, -1472,
-1708, -1886, -2000, -2046, -2022, -1929, -1770, -1552, -1280, -965,
-617, -248, 129, 502, 858, 1185, 1471, 1708, 1886, 2000,
2046, 2022, 1929, 1771, 1552, 1281, 966, 618, 249, -128,
-501, -857, -1184, -1470, -1707, -1885, -1999, -2046, -2022, -1930,
-1772, -1553, -1282, -967, -619, -250, 126, 500, 856, 1183,
1470, 1706, 1885, 1999, 2046, 2022, 1930, 1772, 1554, 1283,
968, 620, 251, -125, -498, -855, -1182, -1469, -1706, -1884,
-1999, -2046, -2022, -1930, -1773, -1555, -1284, -969, -621, -252,
124, 497, 854, 1181, 1468, 1705, 1884, 1999, 2045, 2023,
1931, 1773, 1556, 1285, 970, 622, 254, -123, -496, -852,
-1180, -1467, -1704, -1883, -1998, -2045, -2023, -1931, -1774, -1556,
-1286, -971, -624, -255, 122, 495, 851, 1179, 1466, 1704,
1883, 1998, 2045, 2023, 1932, 1775, 1557, 1287, 972, 625,
256, -120, -494, -850, -1178, -1465, -1703, -1882, -1998, -2045,
-2023, -1932, -1775, -1558, -1288, -973, -626, -257, 119, 493,
849, 1177, 1464, 1702, 1882, 1998, 2045, 2023, 1932, 1776,
1559, 1288, 974, 627, 258, -118, -491, -848, -1176, -1464,
}
};
#endif







//#define HEY

#ifdef HEY

#pragma GCC push_options
//#pragma GCC optimize ("03") // ("-Ofast")

#define EQUALS(a, b)	assert((a) == (b))
#define CLOSE(a, b)							\
	assert(								\
		fabs(static_cast<float>(a) -				\
		     static_cast<float>(b))	<=			\
		   fabs((2 * a.epsilon * static_cast<float>(a)))	\
	)

#include <limits>
template<typename Q_BASE, typename Q_DOUBLE, int Q_FACT>
class QFixed_ {
	Q_BASE a;

	static constexpr Q_DOUBLE Q_MAX = std::numeric_limits<Q_BASE>::max();
	static constexpr Q_DOUBLE Q_MIN = std::numeric_limits<Q_BASE>::min();
	static constexpr Q_DOUBLE K = (1 << (Q_FACT - 1));
	static constexpr float DIV = (1 << Q_FACT);

	typedef QFixed_<Q_BASE, Q_DOUBLE, Q_FACT> MY_TYPE;

	static Q_BASE saturateRaw(Q_DOUBLE x) {
		if (x > Q_MAX)
			return Q_MAX;
		else if (x < Q_MIN)
			return Q_MIN;
		else
			return x;
	}

	static MY_TYPE saturate(Q_DOUBLE x) {
		return from_raw(saturateRaw(x));
	}

public:
	typedef Q_BASE base_type;
	typedef Q_DOUBLE double_base_type;

	static constexpr float epsilon = 1./(1 << Q_FACT);

	QFixed_(float a_ = 0) : a(saturateRaw(a_ * DIV)) {}

	static MY_TYPE from_float(float a) {
		return MY_TYPE(a);
	}

	static MY_TYPE from_raw(Q_BASE a) {
		MY_TYPE r;
		r.a = a;
		return r;
	}

	static MY_TYPE from_Q_DOUBLE(Q_DOUBLE a) {
		return saturate(a << Q_FACT);
	}

	operator float() const {
#ifdef DEBUG_OPS
		std::cout << *this << " float" << std::endl;
#endif
		return static_cast<float>(a) / DIV;
	}

	MY_TYPE operator +(const MY_TYPE &other) {
#ifdef DEBUG_OPS
		std::cout << *this << " + " << other << std::endl;
#endif
		return saturate((Q_DOUBLE)a + (Q_DOUBLE)other.a);
	}

	MY_TYPE operator -(const MY_TYPE &other) {
#ifdef DEBUG_OPS
		std::cout << *this << " - " << other << std::endl;
#endif
		return from_raw(a - other.a);
	}

	MY_TYPE operator *(const MY_TYPE &other) {
		Q_DOUBLE temp;

		temp = (Q_DOUBLE)a * (Q_DOUBLE)other.a;

#ifdef DEBUG_OPS
		std::cout << *this << " * " << other << std::endl;
#endif

		// round up
		temp += K;


		// Correct by dividing by base and saturate result
		return saturate(temp >> Q_FACT);
	}

	/* FIXME(pboldin): these maybe slower than ideal */
	MY_TYPE &operator *=(const MY_TYPE &other) {
#ifdef DEBUG_OPS
		std::cout << *this << " *= " << other << std::endl;
#endif
		*this = (*this * other);
		return *this;
	}

	MY_TYPE &operator +=(const MY_TYPE &other) {
#ifdef DEBUG_OPS
		std::cout << *this << " += " << other << std::endl;
#endif
		*this = *this + other;
		return *this;
	}

	MY_TYPE &operator -=(const MY_TYPE &other) {
#ifdef DEBUG_OPS
		std::cout << *this << " -= " << other << std::endl;
#endif
		*this = *this - other;
		return *this;
	}

	bool operator ==(const MY_TYPE &other) {
		return a == other.a;
	}

	bool operator ==(const int &other) {
		return a == (other << Q_FACT);
	}

	friend MY_TYPE exp(const MY_TYPE &my) {
		return MY_TYPE::from_float(exp(static_cast<float>(my)));
	}

	friend MY_TYPE sin(const MY_TYPE &my) {
		return MY_TYPE::from_float(sin(static_cast<float>(my)));
	}

	friend MY_TYPE cos(const MY_TYPE &my) {
		return MY_TYPE::from_float(cos(static_cast<float>(my)));
	}

#ifdef OSTREAM
	friend std::ostream &operator <<(std::ostream &os, const MY_TYPE &qf) {
		os << "{ a = " << qf.a << " }";
		return os;
	}
#endif
};
typedef QFixed_<int32_t, int64_t, 20> QFixed;

void test_qfixed()
{
	QFixed q = 10, p = 20, o = QFixed::from_float(1.5);

	EQUALS(q + p, 30);
	EQUALS(q * p, 200);
	EQUALS(p * o, 30);
	EQUALS(o * o, QFixed::from_float(2.25));
	EQUALS(q - p, -10);

	q *= p;
	EQUALS(q, 200);
	p *= o;
	EQUALS(p, 30);

	QFixed pisquare_1 = QFixed::from_float(M_PI) * QFixed::from_float(M_PI);
	QFixed pisquare_2 = QFixed::from_float(M_PI * M_PI);
	CLOSE(pisquare_1, pisquare_2);

	CLOSE(QFixed::from_float(M_PI / 2.), M_PI / 2.);

	CLOSE(exp(QFixed::from_float(-1)), QFixed::from_float(exp(-1)));
	CLOSE(sin(QFixed::from_float(M_PI / 2.)), QFixed::from_float(1.));

	{
		QFixed q = QFixed::from_raw(1483322);
		assert((q * q) > 0);
	}
}

#pragma GCC pop_options

#endif /* HEY */

#if GOERTZEL_v3

/*
 * Sliding Windowed Infinite Fourier Transform (SWIFT) in Q-format
 *
 * 2023 (c) Pavel Boldin <pavel.b@techspark.engineering>
 *
 * Compile with make. Add make CFLAGS=-DASWIFT for alpha-SWIFT implementation
 */


float FREQ = frq[ 0 ] / DSP_FD_SAMPLING_RATE;
const float TAU = 500;
const float TAU_fast = 10;

#define Q	8
#define QQ	(1 << Q)

#define Q_BASE		int32_t
#define Q_DOUBLE	int64_t
#define Q_MIN		INT32_MIN
#define Q_MAX		INT32_MAX

/* https://en.wikipedia.org/wiki/Q_%28number_format%29 */
Q_BASE q_add(Q_BASE a, Q_BASE b)
{
	Q_BASE result;
	Q_DOUBLE tmp;

	tmp = (Q_DOUBLE)a + (Q_DOUBLE)b;
	if (tmp > Q_MAX)
		tmp = Q_MAX;
	if (tmp < Q_MIN)
		tmp = Q_MIN;
	result = (Q_BASE)tmp;

	return result;
}

Q_BASE q_sub(Q_BASE a, Q_BASE b)
{
	return a - b;
}

// precomputed value:
#define K   (1 << (Q - 1))

// saturate to range of Q_BASE
Q_BASE satQ(Q_DOUBLE x)
{
	if (x > Q_MAX) return Q_MAX;
	else if (x < Q_MIN) return Q_MIN;
	else return (Q_BASE)x;
}

Q_BASE q_mul(Q_BASE a, Q_BASE b)
{
	Q_BASE result;
	Q_DOUBLE temp;

	temp = (Q_DOUBLE)a * (Q_DOUBLE)b; // result type is operand's type
					// Rounding; mid values are rounded up
	temp += K;
	// Correct by dividing by base and saturate result
	result = satQ(temp >> Q);

	return result;
}

void q_mul_complex(Q_BASE a_i, Q_BASE a_q,
		Q_BASE b_i, Q_BASE b_q,
		Q_BASE *c_i, Q_BASE *c_q)
{
	*c_i = q_sub(q_mul(a_i, b_i), q_mul(a_q, b_q));
	*c_q = q_add(q_mul(a_i, b_q), q_mul(a_q, b_i));
}

void q_add_complex(Q_BASE a_i, Q_BASE a_q,
		Q_BASE b_i, Q_BASE b_q,
		Q_BASE *c_i, Q_BASE *c_q)
{
	*c_i = q_add(a_i, b_i);
	*c_q = q_add(a_q, b_q);
}

void q_sub_complex(Q_BASE a_i, Q_BASE a_q,
		Q_BASE b_i, Q_BASE b_q,
		Q_BASE *c_i, Q_BASE *c_q)
{
	*c_i = q_sub(a_i, b_i);
	*c_q = q_sub(a_q, b_q);
}

/* End of wiki code */

/* It needs some classes, but they are C++, maybe structures? */
void swift(
	Q_BASE val, Q_BASE prev_i, Q_BASE prev_q,
	Q_BASE shift_i, Q_BASE shift_q, Q_BASE *pi, Q_BASE *pq)
{
	Q_BASE i, q;

	q_mul_complex(prev_i, prev_q, shift_i, shift_q, &i, &q);
	i = q_add(i, val);

	*pi = i;
	*pq = q;
}
#endif //#if GOERTZEL_v3



static FLOAT goertzel_sample_rate = DSP_FD_SAMPLING_RATE;
static U32 goertzel_buf_size = DSP_FD_BUF_SIZE;
static U32 goertzel_mashtab = GOERTZEL_MASHTAB;

 S64 re[ DSP_FD_CHANNEL_NUM ];
 S64 im[ DSP_FD_CHANNEL_NUM ];

typedef struct {
    S32 xm1;
    S32 ym1;
} dsp_fd_dc_bloker_t;

dsp_fd_dc_bloker_t dc_bloker[ DSP_FD_CHANNEL_NUM ];
/**
  y = x - xm1 + 0.995 * ym1;
  xm1 = x;
  ym1 = y;
Here, x denotes the current input sample, and y denotes the current output sample.
 The variables xm1 and ym1 hold once-delayed input and output samples, respectively
 (and are typically initialized to zero). In this implementation, the pole is
fixed at $ R=0.995$, which corresponds to an adaptation time-constant of
approximately $ 1/(1-R) = 200$ samples. A smaller $ R$ value allows faster tracking
of ``wandering dc levels'', but at the cost of greater low-frequency attenuation.
 * @brief dsp_fd_dc_bloker
 */
S32 fd_dsp_dc_bloker( dsp_fd_dc_bloker_t *p, S32 ns )
{
#define DSP_FD_DC_BLOCK_COEF	900
#if 1
    S32 x = ns * (( 1000 - DSP_FD_DC_BLOCK_COEF )); //compute new x * 0.05
    x = x * 0xFF; // to fixed point

    S32 y = p->xm1;
    y = y * ( DSP_FD_DC_BLOCK_COEF ); //compute old y * 0.95
    //y = y * 100; //to fixed  point

    y = x + y; //compute sum

    y = y / 1000; //get 100 proc
    p->xm1 = y; //store
    y = y / 0xFF; //from fixed point
//    if( y < 0 )
//        tmp -= 1;

    return ns - y; //compute delta - sub zero level
#else
    ns = ns << 16; //to fixed point
    S32 tmp = DSP_FD_DC_BLOCK_COEF * p->ym1; //old 0.95
    S32 y = ns - p->xm1; //get delta
    y = y + tmp;
    p->xm1 = ns;
    tmp = y >> 16; //from fixed point
    p->ym1 = tmp;
    if( y < 0 )
        return tmp - 1;
    else //if(value >= 0)
        return tmp;
#endif

}

//typedef struct {
//    S32 xm1;
//    S32 ym1;
//} fd_dsp_filter_t;
//
//fd_dsp_filter_t fd_filter[ DSP_FD_CHANNEL_NUM ];
//S32 fd_dsp_filter( fd_dsp_filter_t *p, S32 ns )
//{
//#define DSP_FD_FILT_COEF	980
//    S32 x = ns * (( 1000 - DSP_FD_FILT_COEF ) * 0xFF ); //compute new x * 0.05
//    //x = x * ; // to fixed point
//
//    S32 y = p->xm1;
//    y = y * ( DSP_FD_FILT_COEF ); //compute old y * 0.95
//    //y = y * 100; //to fixed  point
//
//    y = x + y; //compute sum
//
//    y = y / 1000; //get 100 proc
//    p->xm1 = y; //store
//    y = y / 0xFF; //from fixed point
////    if( y < 0 )
////        tmp -= 1;
//
//    return y; //compute delta - sub zero level
//}


void fd_dsp_frq_set( U32 n, FLOAT f )
{
#if DSP_FD_CODE_RAM
	test_param( f >= DSP_FD_SAMPLING_RATE / 2.0f );
    frq[ n ] = f;
#endif
}

FLOAT fd_dsp_frq_get( U32 n )
{
#if DSP_FD_CODE_RAM
    return frq[ n ];
#else
    return 0;
#endif
}

void fd_dsp_sample_rate_set( FLOAT sr )
{
	//test_param( sr < 1.0 );
	//test_param( sr > DSP_FD_SAMPLING_RATE ); //TODO
    goertzel_sample_rate = sr;
}

FLOAT fd_dsp_sample_rate_get( void )
{
    return goertzel_sample_rate;
}

void fd_dsp_buf_size_set( U32 s )
{
	test_param( s > DSP_FD_BUF_SIZE );
	goertzel_buf_size = s;
}

U32 fd_dsp_buf_size_get( void )
{
	return goertzel_buf_size;
}

void fd_dsp_mashtab_set( U32 m )
{
	test_param( m > 31 ); //TODO
	goertzel_mashtab = m;
}

U32 fd_dsp_mashtab_get( void )
{
	return goertzel_mashtab;
}

#if GOERTZEL_v2
static FLOAT s_prev[ DSP_FD_CHANNEL_NUM ];
static FLOAT s_prev2[ DSP_FD_CHANNEL_NUM ];
//static FLOAT totalpower = 0.0;
static int N = 0;
static FLOAT coeff[ DSP_FD_CHANNEL_NUM ];
#endif

#if GOERTZEL_v3
#define I_OFFSET 0
#define Q_OFFSET 1
static Q_BASE s_prev[ 2 * DSP_FD_CHANNEL_NUM ];
static Q_BASE shift_i = 0, shift_q = 0;
#endif

void fd_dsp_init( void )
{
#ifdef HEY
    test_qfixed();
#endif

//	//dc remove filter init
//    for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
//	{
//        //dc_bloker[i].xm1 = 0;
//	}
#if GOERTZEL_v1 && DSP_FD_CODE_RAM
	// FFT-Goertzel init =======================================================
	//for( j = 0; j < DSP_FD_FRQ_NUM; j++ )
//	{
//    	FLOAT omega = ( (FLOAT)2.0 * (FLOAT)_PI * (FLOAT)frq[0] ) / (FLOAT)dsp_fd_sample_rate_get();
//	    for( U32 i = 0; i < goertzel_buf_size; i++ )
//	    {
//            gsin_buf[i] = sinf( (FLOAT)i * omega ) * (FLOAT)2047.0f;
//            gcos_buf[i] = cosf( (FLOAT)i * omega ) * (FLOAT)2047.0f;
//	    }
//	}
	for( U32 j = 0; j < DSP_FD_FRQ_NUM; j++ )
	{
        DOUBLE omega = ( 2.0 * _PI * (DOUBLE)frq[j] ) / fd_dsp_sample_rate_get();
	    for( U32 i = 0; i < goertzel_buf_size; i++ )
	    {
            gsin_buf[j][i] = sin( (DOUBLE)i * omega ) * (DOUBLE)0x7FF;
            gcos_buf[j][i] = cos( (DOUBLE)i * omega ) * (DOUBLE)0x7FF;
	    }
	}
#endif
#if GOERTZEL_v2
	// Sliding FFT-Goertzel init ===============================================
	//for( j = 0; j < DSP_FD_FRQ_NUM; j++ )
	{
		for( U32 i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
		{
			s_prev[i] = 0.0;
			s_prev2[i] = 0.0;
			//totalpower = 0.0;
			//N = 0;
			coeff[i] = 2 * cos( 2 * _PI * frq[0] / dsp_fd_sample_rate_get() );

			fd_filter[i].xm1 = 0;
			fd_filter[i].ym1 = 0;
		}
	}
#endif
#if GOERTZEL_v3
	FLOAT scale = exp(-1./TAU) * QQ;

	shift_i = satQ(cos(2. * M_PI * FREQ) * scale);
	shift_q = satQ(sin(2. * M_PI * FREQ) * scale);
#endif
}

//#define SNR_DELAY	25//70 //25
//filter_window_32b_t filt_snr[4] = { {.tmp = 0, .window = SNR_DELAY },{.tmp = 0, .window = SNR_DELAY },{.tmp = 0, .window = SNR_DELAY },{.tmp = 0, .window = SNR_DELAY } };
static S32 ref_val[8];

#pragma GCC push_options
//#pragma GCC optimize ("03") // ("-Ofast")
void fd_dsp_process_v1( U16 *p, fd_data_t *fdp )
{
#if GOERTZEL_v1
    UINT i, n;
    S32 tmpS32;
//	U32 rssi;
    S32 tmpV;
    S64 mag;
    U16 *pp;

	pp = p; //init pointer

	// looking for the ref value for each channel
	for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
	{
		ref_val[i] = 0;
	}
	for( n = 0; n < goertzel_buf_size; n++ )
	{
		for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
		{
			tmpS32 = (S32)*pp++; //get value
			ref_val[i] += tmpS32;
		}
	}
	for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
	{
		ref_val[i] = ref_val[i] / goertzel_buf_size;
	}

	// compute reduced FFT or Goertzel
    for( INT j = 0; j < 1; j++ )//DSP_FD_FRQ_NUM
    {
		for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ ) //set to zero
		{
			re[i] = 0;
			im[i] = 0;
		}

        pp = p; //reinit pointer

        for( n = 0; n < DSP_FD_BUF_SIZE; n++ )
		{
			for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
			{
                tmpS32 = (S32)*pp++; //get value

				/* remove ref_val */
                //tmpS32 = dsp_fd_dc_bloker( &dc_bloker[i], tmpS32 );
                tmpS32 = tmpS32 - ref_val[i]; //2048;

				/* compute real and image values */
                tmpV = (S32)gsin_buf[j][n] * tmpS32;
                re[i] = re[i] + tmpV;
                tmpV = (S32)gcos_buf[j][n] * tmpS32;
                im[i] = im[i] + tmpV;
			}
		}

        // compute magnitude of signals
		for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
		{
            re[i] = re[i] / 1000;
            im[i] = im[i] / 1000;
			re[i] = ( re[i] * re[i] ); //^2
			im[i] = ( im[i] * im[i] ); //^2
			mag = sqrtf( re[i] + im[i] ); //sum

            if( mag > 0x7FFFFFFF ) // todo test for overflow
			{
                mag = 0x7FFFFFFF;
			}

			mag = ( mag );//>> 6;// >> goertzel_mashtab; // divider

			fdp->v[ j * DSP_FD_CHANNEL_NUM + i ] = mag; //save

        }

//		// compute stretch of signal
//		for( n = 0; n < DSP_FD_CHANNEL_NUM / 4; n++ )
//		{
//	        rssi = 0;
//			for( i = 0; i < 4; i++ )
//			{
//				rssi += fdp->v[ j * DSP_FD_CHANNEL_NUM + n * 4 + i ];
//	        }
//
//			fdp->rssi[ j * DSP_FD_CHANNEL_NUM / 4 + n ] = rssi; //save rssi
//        }

//		tmpV = 0;
//		for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
//		{
//			tmpS32 = (fdp->v_old[i] - fdp->v[i] );
//			tmpS32 = tmpS32 > 0 ? tmpS32 : tmpS32 * -1; //aqbs
//			tmpV += tmpS32;
//			fdp->v_old[i] = fdp->v[i]; //store for future use
//		}

		//fdp->snr[j] = filter_window_S32( &filt_snr[0],  (rssi) / ( tmpV ));
	}

#if( 8 == DSP_FD_CHANNEL_NUM )
    U32 rssi;
	// compute stretch of signal after 1-x cascade for 1frq
	rssi = fdp->v[0]  + fdp->v[1]  + fdp->v[2]  + fdp->v[3]; // signal level for 1 frq
	fdp->rssi[0] = _constrain( rssi, 1, 0xFFFF );

	// compute stretch of signal after 2-x cascade for 1frq
	rssi = fdp->v[4]  + fdp->v[5]  + fdp->v[6]  + fdp->v[7];
	fdp->rssi[1] = _constrain( rssi, 1, 0xFFFF );

	// compute stretch of signal after 1-x cascade for 2frq
	rssi = fdp->v[8]  + fdp->v[9]  + fdp->v[10] + fdp->v[11];
	fdp->rssi[2] = _constrain( rssi, 1, 0xFFFF );

	// compute stretch of signal after 2-x cascade for 2frq
	rssi = fdp->v[12] + fdp->v[13] + fdp->v[14] + fdp->v[15];
	fdp->rssi[3] = _constrain( rssi, 1, 0xFFFF );

	// compute signal to noise ratio
	S32 rssiA, rssiB;

	// signal level after 1-x cascade
	rssiA = fdp->rssi[0];
	rssiB = _constrain( fdp->rssi[2] >> 10, 1, 0xFFFF );
	fdp->snr[0] = rssiA / rssiB;

	// signal level after 2-x cascade
	rssiA = fdp->rssi[1];
	rssiB = _constrain( fdp->rssi[3] >> 10, 1, 0xFFFF );
	fdp->snr[1] = rssiA / rssiB;



	// signal level after 2-x cascade for 1ch
	rssiA = fdp->v[0];
	rssiB = _constrain( fdp->v[0] >> 10, 1, 0xFFFF );
	fdp->snr[2] = rssiB;

	// signal level after 2-x cascade for 2ch
	rssiA = fdp->v[1];
	rssiB = _constrain( fdp->v[1] >> 10, 1, 0xFFFF );
	fdp->snr[3] = rssiB;

	// signal level after 2-x cascade for 3ch
	rssiA = fdp->v[2];
	rssiB = _constrain( fdp->v[2] >> 10, 1, 0xFFFF );
	fdp->snr[4] = rssiB;

	// signal level after 2-x cascade for 4ch
	rssiA = fdp->v[3];
	rssiB = _constrain( fdp->v[3] >> 10, 1, 0xFFFF );
	fdp->snr[5] = rssiB;
#else

//	// compute stretch of signal after 1-x cascade for 1frq
//	rssi = fdp->v[0]  + fdp->v[1]  + fdp->v[2]  + fdp->v[3]; // signal level for 1 frq
//	fdp->rssi[0] = _constrain( rssi, 1, 0xFFFF );

//	rssi = fdp->v[4]  + fdp->v[5]  + fdp->v[6]  + fdp->v[7];
//	fdp->rssi[1] = _constrain( rssi, 1, 0xFFFF );

//	rssi = fdp->v[8]  + fdp->v[9]  + fdp->v[10] + fdp->v[11];
//	fdp->rssi[2] = _constrain( rssi, 1, 0xFFFF );

//	rssi = fdp->v[12] + fdp->v[13] + fdp->v[14] + fdp->v[15];
//	fdp->rssi[3] = _constrain( rssi, 1, 0xFFFF );

//	rssi = fdp->v[8]  + fdp->v[9]  + fdp->v[10] + fdp->v[11];
//	fdp->rssi[4] = _constrain( rssi, 1, 0xFFFF );

//	rssi = fdp->v[12] + fdp->v[13] + fdp->v[14] + fdp->v[15];
//	fdp->rssi[5] = _constrain( rssi, 1, 0xFFFF );

//	// compute signal to noise ratio
//	S32 rssiA, rssiB;

//	// signal level after 1-x cascade
//	rssiA = fdp->rssi[0];
//	rssiB = _constrain( fdp->rssi[2] >> 10, 1, 0xFFFF );
//	fdp->snr[0] = rssiA / rssiB;

//	// signal level after 2-x cascade
//	rssiA = fdp->rssi[1];
//	rssiB = _constrain( fdp->rssi[3] >> 10, 1, 0xFFFF );
//	fdp->snr[1] = rssiA / rssiB;


//	// signal level after 2-x cascade for 1ch
//	rssiA = fdp->v[0];
//	rssiB = _constrain( fdp->v[8] >> 10, 1, 0xFFFF );
//	fdp->snr[2] = rssiA / rssiB;

//	// signal level after 2-x cascade for 2ch
//	rssiA = fdp->v[1];
//	rssiB = _constrain( fdp->v[9] >> 10, 1, 0xFFFF );
//	fdp->snr[3] = rssiA / rssiB;

//	// signal level after 2-x cascade for 3ch
//	rssiA = fdp->v[2];
//	rssiB = _constrain( fdp->v[10] >> 10, 1, 0xFFFF );
//	fdp->snr[4] = rssiA / rssiB;

//	// signal level after 2-x cascade for 4ch
//	rssiA = fdp->v[3];
//	rssiB = _constrain( fdp->v[11] >> 10, 1, 0xFFFF );
//	fdp->snr[5] = rssiA / rssiB;
#endif


#endif //GOERTZEL_v1

#if GOERTZEL_v2
    FLOAT s, power;

    //for( j = 0; j < DSP_FD_FRQ_NUM; j++ )
    {
    	N = 0;
    	rssi = 0;
        for( n = 0; n < goertzel_buf_size; n++ )
		{
			for( i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
			{
                tmpS32 = (S32)*p++; //get value

				// remove dc level
                tmpS32 = tmpS32 - 2048;//
                //tmpS32 = dsp_fd_dc_bloker( &dc_bloker[i], tmpS32 );

                s = tmpS32 + coeff[i] * s_prev[i] - s_prev2[i];
                s_prev2[i] = s_prev[i];
                s_prev[i] = s;

                N++;
    			power = s_prev2[i] * s_prev2[i] + s_prev[i] * s_prev[i]
					- coeff[i] * s_prev[i] * s_prev2[i];

    			//totalpower += tmpS32 * tmpS32;
    			//if (totalpower == 0) totalpower = 1;
    			fdp->v[i] = 2 + ( power ) / ( 1 << goertzel_mashtab );// / totalpower;// / N;

    			//level[j][i] = dsp_fd_filter( &fd_filter[i], level[j][i] );

			}
		}
        fdp->rssi = rssi;
	}
#endif //GOERTZEL_v2
}

#if GOERTZEL_v3
void fd_dsp_process_v3( U16 *p, fd_data_t *fdp )
{
    UINT i, n;
 	U32 rssi = 0;

 	for (n = 0; n < goertzel_buf_size; n++ ) {
 		for (i = 0; i < DSP_FD_CHANNEL_NUM; i++ ) {
 			S32 val = (*p++);
 			val -= 2048;
 			val <<= Q;
 			swift(val,
 				  s_prev[i * 2 + I_OFFSET],
 				  s_prev[i * 2 + Q_OFFSET],
 				  shift_i, shift_q,
 				  &s_prev[i * 2 + I_OFFSET],
 				  &s_prev[i * 2 + Q_OFFSET]);
 		}
 	}

 	for (i = 0; i < DSP_FD_CHANNEL_NUM; i++) {
 		FLOAT ii = (FLOAT)s_prev[i * 2 + I_OFFSET] / QQ,
 			   q = (FLOAT)s_prev[i * 2 + Q_OFFSET] / QQ;

 		fdp->v[i] = sqrt(ii*ii + q*q);
 		rssi += fdp->v[i];

 	}
 	fdp->rssi[0] = rssi;
}
#endif

void fd_dsp_vector_get( fd_data_t *fd, FLOAT amp )
{
	FLOAT q1, q2, q3, q4, q5, q6, qsum, x, y;
	UINT i;

	test_param( fd == NULL );
	test_param( amp > 10000 );
	//test_param( fd->fd_num == 0 );
	//test_param( fd->fd_num > 4 );
	//test_param( vp == NULL );

	x = 0;
	y = 0;
    //for( U32j = 0; j < DSP_FD_FRQ_NUM; j++ )
	{
    	switch( fd->fd_num )
    	{
    	case 1:
    		//get values
    		q1 = fd->v[0];
    		qsum = q1;
            x = 0;
            y = 0;
    		break;

    	case 2:
    		//get values
    		q1 = fd->v[0];
    		q2 = fd->v[1];

    		//compute 1d vector
    		qsum = q1 + q2;
    		qsum = ( qsum == 0 ) ? 1 : qsum; //for division to zero!
    		x = ( ( q1 - q2 ) * amp ) / qsum;
    		break;

    	case 3:
//    		switch( fd->vector_mode )
//    		{
//    		case 0:
//        		//get values
//        		q1 = fd->v[0];
//        		q2 = fd->v[1];
//        		q3 = fd->v[2];
//
//        		//compute 2d vector
//        		fx = ( ( q1 - q2 ) / ( q1 + q2 ) ) * amp;
//        		fy = ( ( ( q1 + q2 ) / 2 - q3 ) / ( ( q1 + q2 ) / 2 + q3 ) ) * amp;
//        		break;
//
//    		case 1:
				//get values
				q1 = fd->v[0];
				q2 = fd->v[1];
				q3 = fd->v[2];

#define M_SQRT_3_OVER_2 0.8660254037844387f
				//compute 2d vector
				x = (q1 - (q2 + q3) / 2);
				y = M_SQRT_3_OVER_2 * (q2 - q3);
//				break;
//
//    		case 2: {
//				UINT max = 0;
//				static const FLOAT v[3][2] = {
//						{ 1.0, 0.0 },
//						{-0.4999999999999998, 0.8660254037844387},
//						{-0.5000000000000004, -0.8660254037844385}
//				};
//
//				for (i = 0; i < 3; i++)
//					max = (max > fd->v[i]) ? max : fd->v[i];
//
//				//get values
//				for (i = 0; i < 3; i++) {
//					fx += v[i][0] * fd->v[i] / max;
//					fy += v[i][1] * fd->v[i] / max;
//				}
//    		} break;
//    		default: break;
//    		}
    	break;

		case 4:
		case 8:
            for( i = 0; i < fd->fd_num; i += 4 )
			{
				//get values
				q1 = fd->v[i+0];
				q2 = fd->v[i+1];
				q3 = fd->v[i+2];
				q4 = fd->v[i+3];

                qsum = q1 + q2 + q3 + q4;// old

                //qsum = sqrtf( q1*q1 + q2*q2 + q3*q3 + q4*q4 );

				qsum = ( qsum < 1 ) ? 1 : qsum; //for division to zero!

				//compute 2d vector
				x = ((( q1 + q4 ) - ( q2 + q3 ))) / qsum;
				y = ((( q1 + q2 ) - ( q4 + q3 ))) / qsum;

				x = x * amp;
				y = y * amp;

				// correction
				if( x > amp )
					x = amp;
                if( x < ( amp * -1 ))
                    x = ( amp * -1 );
				if( y > amp )
					y = amp;
                if( y < ( amp * -1 ))
                    y = ( amp * -1 );

				//store points for all level
                fd->x[i/4] = x;//_constrain( fx, -(AREA_SIZE), AREA_SIZE );
                fd->y[i/4] = y;//_constrain( fy, -(AREA_SIZE), AREA_SIZE );

			}
			break;

		case 12:
			for( i = 0; i < 12; i += 6 )
			{
				//get values
				q1 = fd->v[i+0];
				q2 = fd->v[i+1];
				q3 = fd->v[i+2];
				q4 = fd->v[i+3];
				q5 = fd->v[i+4];
				q6 = fd->v[i+5];

				qsum = q1 + q2 + q3 + q4 + q5 + q6;//qsum = fd->rssi; //22+44+66+44=176
				qsum = ( qsum < 1 ) ? 1 : qsum; //for division to zero!
				//todo divide to max or sum?
				//compute 2d vector
				x = ((( q1 + q4 ) - ( q2 + q3 ))) / qsum;
				y = ((( q1 + q2 ) - ( q4 + q3 ))) / qsum;

				x = x * amp;
				y = y * amp;

//				// correction
//				if( x > amp )
//					x = amp;
//				if( x < ( amp * -1 ) )
//					x = ( amp * -1 ) ;
//				if( y > amp )
//					y = amp;
//				if( y < ( amp * -1 ) )
//					y = ( amp * -1 ) ;

				//store points for all level
				fd->x[i/6] = x;
				fd->y[i/6] = y;
			}
			break;

		default: break;
		}
	}
}

#include "_misc.h"

#pragma GCC pop_options

//static FLOAT calibrate_angle[ FD_CALIBRATE_DOTS ];
extern FLOAT angle;

void fd_dsp_calibrate_vector_get( fd_data_t *pfd_data, FLOAT *clb_val )
{
    vector_2D_FLOAT_t vxy;
    test_param( pfd_data == NULL );
    test_param( clb_val == NULL );

    for( INT i = 0; i < 2; i++ ) //for branches
    {
    	// get values
        vxy.x = pfd_data->x[i];
        vxy.y = pfd_data->y[i];

        pfd_data->len[i] = vect_len_FLOAT( &vxy ); //sqrtf( vxy.x * vxy.x + vxy.y * vxy.y );//

        if( 0 == vxy.x )
        	vxy.x = vxy.x + 0.000001f;
        if( 0 == vxy.y )
        	vxy.y = vxy.y + 0.000001f;

        pfd_data->dir[i] = atan2f( vxy.y, vxy.x ) * RAD2DEG;

        //correction, from -/+180 to 0 - 360
        S32 bufpos = (S32)pfd_data->dir[i] + FD_CLB_DOTS/2;
        //test_param( bufpos >= FD_CALIBRATE_DOTS );
//        if( bufpos > (FD_CALIBRATE_DOTS)) //!
//        {
//            bufpos = FD_CALIBRATE_DOTS;
//        }
//        if( bufpos < 0 )
//        {
//            bufpos = 0;
//        }
        //test_param( bufpos < 0 );

        pfd_data->bufpos[i] = bufpos;

        //    result.x = p1.x + t * (p2.x - p1.x);
        //    result.y = p1.y + t * (p2.y - p1.y);
            //fd->dir[1] = bufpos;//dir;
        FLOAT clb_len = pfd_data->len[i] * clb_val[ i * FD_CLB_DOTS + bufpos ];

        pfd_data->fx[i] = _vect_x_FLOAT( clb_len, pfd_data->dir[i] );
        pfd_data->fy[i] = _vect_y_FLOAT( clb_len, pfd_data->dir[i] );
    }
}



#if FD_DRAW
#include "colors.h"
#include "halPaint.h"
#include "modPaint.h"
//#include "_filter.h"
#include "xprintf.h"


void fd_dsp_paint_vector( COORD center_x, COORD center_y, COORD x, COORD y, COORD mark_size )
{
#if( 1 == FD_DSP_CROSS_TYPE )//xcross + dot
	paint_line_x( center_x + x - mark_size, center_y + y, mark_size/2 );
	paint_line_x( center_x + x + mark_size/2, center_y + y, mark_size/2 );
	paint_line_y( center_x + x, center_y + y - mark_size, mark_size/2 );
	paint_line_y( center_x + x, center_y + y + mark_size/2, mark_size/2 );
	paint_pixel( center_x + x, center_y + y );
#endif
#if ( 2 == FD_DSP_CROSS_TYPE )//BOARD_0_miniF401 //xcross thick
	paint_line_x( center_x + x - mark_size, center_y + y-1, mark_size/2 );
	paint_line_x( center_x + x - mark_size, center_y + y, mark_size/2 );
	paint_line_x( center_x + x - mark_size, center_y + y+1, mark_size/2 );

	paint_line_x( center_x + x + mark_size/2, center_y + y-1, mark_size/2 );
	paint_line_x( center_x + x + mark_size/2, center_y + y, mark_size/2 );
	paint_line_x( center_x + x + mark_size/2, center_y + y+1, mark_size/2 );

	paint_line_y( center_x + x-1, center_y + y - mark_size, mark_size/2 );
	paint_line_y( center_x + x, center_y + y - mark_size, mark_size/2 );
	paint_line_y( center_x + x+1, center_y + y - mark_size, mark_size/2 );

	paint_line_y( center_x + x-1, center_y + y + mark_size/2, mark_size/2 );
	paint_line_y( center_x + x, center_y + y + mark_size/2, mark_size/2 );
	paint_line_y( center_x + x+1, center_y + y + mark_size/2, mark_size/2 );
#endif
#if ( 3 == FD_DSP_CROSS_TYPE ) //simple cross
	paint_line_x( center_x + x - (mark_size>>1), center_y + y, mark_size );
	paint_line_y( center_x + x, center_y + y - (mark_size>>1), mark_size );
#endif
}

static CHAR str[64];
void fd_dsp_paint_digit( COORD x, COORD y, U32 val )
{
	COORD xn = x;

//	if( val < 1000000000 )
//		xsprintf( str, "  " );
//	else
//		xsprintf( str, "%2u", val / 1000000000 );
//	xn = paint_text_xy( x, y, str );
//	val = val % 1000000000;
	if( val < 1000000 )
		xsprintf( str, "   " );
	else
		xsprintf( str, "%3u", val / 1000000 );
	xn = paint_text_xy( xn + 2, y, str );
	val = val % 1000000;
	if( val < 1000 )
		xsprintf( str, "   " );
	else
		xsprintf( str, "%3u", ( val % 1000000 ) / 1000 );
	xn = paint_text_xy( xn + 2, y, str );
	//val = val % 1000;
	if( val > 1000 )
		xsprintf( str, "%03u", val % 1000 );
	else
		xsprintf( str, "%3u", val % 1000 );
	paint_text_xy( xn + 2, y, str );
}

extern U16 calibration;
extern U16 set_PID_on;

COORD line_train_x[2][256];
COORD line_train_y[2][256];
static COLOR colors[ DSP_FD_CHANNEL_NUM ] = {};

COLOR fd_dsp_paint_color( U8 num )
{
	return colors[ num ];
}

void fd_dsp_draw( fd_data_t *pfd_data, U8 mode, U32 mul )
{
	static BOOL color_generation = FALSE;
	static COORD center_x;
	static COORD center_y;

	static fd_data_t prev_fd_data;
	static U32 tmpfA0 = 0;
    static U32 tmpfA1 = 0;
	static U32 tmpfA2 = 0;
	static U32 tmpfA3 = 0;
	static U32 tmpfA4 = 0;
	static U32 tmpfA5 = 0;
	static U32 radius;

	//static filter_window_FLOAT_t fwf0;
	//static filter_window_FLOAT_t fwf1;
	static U8 delay_cnt = 0;
	COORD xn;


    if( color_generation == FALSE )
    {
        U32 hue;
        color_generation = TRUE;
        for( INT i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
        {
            hue = ((100 * i) / 4 );
            colors[i] = HSV_to_RGB( hue, 255, 255 );
        }
//
//    	fwf0.window = 90.0;
//    	fwf1.window = 90.0;

    	center_x = hal_paint_screen_width()/2;
    	center_y = hal_paint_screen_height()/2 + 11;

        for( INT i = 0; i < 128; i++ )
		{
            line_train_x[0][i] = center_x;
            line_train_y[0][i] = center_y;
            line_train_x[1][i] = center_x;
            line_train_y[1][i] = center_y;
		}
    }

    fd_dsp_vector_get( pfd_data, GRID_SIZE*GRID_N * mul );

	// clear old point
	paint_color( COLOR_BLACK );

    for( INT i = 0; i < FD_DSP_TRAIN_DOTS; i++ )
	{
        paint_line( line_train_x[1][i], line_train_y[1][i], line_train_x[1][i+1], line_train_y[1][i+1] );
	}

	for( INT i = 0; i < 2; i++ )
	{
		fd_dsp_paint_vector( center_x, center_y, prev_fd_data.x[i], prev_fd_data.y[i], MARK_SIZE );
	}
//	dsp_fd_paint_vector( center_x, center_y,
//			prev_fd_vector.x[1], prev_fd_vector.y[1], mark_size );

#if BOARD_712_Lift
	paint_circle( center_x, center_y, radius, PAINT_QUARTERS_ALL, 0 );
#endif

	// copy new coordinates ----------------------------------------------------
	prev_fd_data.x[0] = _constrain( pfd_data->x[0], -(AREA_SIZE), AREA_SIZE );
	prev_fd_data.y[0] = _constrain( pfd_data->y[0], -(AREA_SIZE), AREA_SIZE );
	prev_fd_data.x[1] = _constrain( pfd_data->x[1], -(AREA_SIZE), AREA_SIZE );
	prev_fd_data.y[1] = _constrain( pfd_data->y[1], -(AREA_SIZE), AREA_SIZE );

	// draw x-cross ------------------------------------------------------------
	paint_color( COLOR_BLUE );
	paint_line( center_x, center_y - AREA_SIZE, center_x, center_y + AREA_SIZE );
	paint_line( center_x - AREA_SIZE, center_y, center_x + AREA_SIZE, center_y );

	// draw coord grid ---------------------------------------------------------
	paint_color( COLOR_BLUE + COLOR_GREEN );
	for( COORD j = -(AREA_SIZE); j <= AREA_SIZE; j += GRID_SIZE )
	{
		for( COORD i = -(AREA_SIZE); i <= AREA_SIZE; i += GRID_SIZE )
		{
			paint_pixel( center_x + j, center_y + i );
		}
	}


	//move points from worm
	for( INT i = 128 -1; i > 0; i-- )
	{
        line_train_x[1][i] = line_train_x[1][i-1];
        line_train_y[1][i] = line_train_y[1][i-1];
	}
    line_train_x[1][0] = prev_fd_data.x[1] + center_x;
    line_train_y[1][0] = prev_fd_data.y[1] + center_y;
    line_train_x[1][0] = _constrain( line_train_x[1][0], 0, hal_paint_screen_width()-1 );
    line_train_y[1][0] = _constrain( line_train_y[1][0], 0, hal_paint_screen_height()-1 );

	paint_color( COLOR_LIME );
    for( INT i = 0; i < FD_DSP_TRAIN_DOTS; i++ )
	{
        paint_line( line_train_x[1][i], line_train_y[1][i], line_train_x[1][i+1], line_train_y[1][i+1] );
	}

	paint_color( COLOR_LIME );
	fd_dsp_paint_vector( center_x, center_y, prev_fd_data.x[1], prev_fd_data.y[1], MARK_SIZE );

	if( mode )
	{
		paint_color( COLOR_ORANGE );
		fd_dsp_paint_vector( center_x, center_y, prev_fd_data.x[0], prev_fd_data.y[0], MARK_SIZE );
	}


	U32 tmpf0 = _constrain( pfd_data->snr[0], 0, 0xFFFF );
	U32 tmpf1 = _constrain( pfd_data->snr[1], 0, 0xFFFF );//filter_window_FLOAT( &fwf1, pfd_data->snr );

	U32 tmpf2 = _constrain( pfd_data->snr[2], 0, 0xFFFF );
	U32 tmpf3 = _constrain( pfd_data->snr[3], 0, 0xFFFF );
	U32 tmpf4 = _constrain( pfd_data->snr[4], 0, 0xFFFF );
	U32 tmpf5 = _constrain( pfd_data->snr[5], 0, 0xFFFF );

#if BOARD_0_miniF401
	if( ++delay_cnt > 5 )
#else
	if( ++delay_cnt > 1 )
#endif
	{
		delay_cnt = 0;

		tmpfA0 = tmpf0;
		tmpfA1 = tmpf1;
		tmpfA2 = tmpf2;
		tmpfA3 = tmpf3;
		tmpfA4 = tmpf4;
		tmpfA5 = tmpf5;

		for( INT i = 0; i < 4; i++ ) //DSP_FD_CHANNEL_NUM
		{
			if( mode )
			{
				paint_color( fd_dsp_paint_color( i ));
			}
			else
				paint_color( COLOR_BLACK );
#if BOARD_712_Lift

			xsprintf( str, "ch %2u ", i + 9 );
			xn = paint_text_xy( 8, 2 + 12 * i, str );
			fd_dsp_paint_digit( xn, 2 + 12 * i, pfd_data->v[i] );

#else
			xsprintf( str, "ch %u           ", i + 1 );
			xn = paint_text_xy( 45, 2 + 12 * i, str ); //xn = paint_text_xy( 2, 2 + 23 * i, str );
			fd_dsp_paint_digit( xn, 2 + 12 * i, pfd_data->v[i] ); //fd_dsp_paint_digit( xn, 2 + 23 * i, pfd_data->v[i] );
#endif
		}


		for( INT i = 4; i < 8; i++ ) //DSP_FD_CHANNEL_NUM
		{
			paint_color( fd_dsp_paint_color( i ) );
#if BOARD_712_Lift

			xsprintf( str, "ch %u ", i + 9 );
			xn = paint_text_xy( 8, 2 + 12 * i, str );
			fd_dsp_paint_digit( xn, 2 + 12 * i, pfd_data->v[i] );

#else
			xsprintf( str, "ch %u           ", i + 1 );
			xn = paint_text_xy( 45, 2 + 12 * i, str ); //xn = paint_text_xy( 2, 2 + 23 * i, str );
			fd_dsp_paint_digit( xn, 2 + 12 * i, pfd_data->v[i] ); //fd_dsp_paint_digit( xn, 2 + 23 * i, pfd_data->v[i] );
#endif
		}
	}

#if BOARD_712_Lift
	paint_color( COLOR_ORANGE );
	xsprintf( str, "snr1" );
	xn = paint_text_xy( 8, hal_paint_screen_height()-100, str );
	fd_dsp_paint_digit( xn, hal_paint_screen_height()-100, tmpfA0 );

	paint_color( COLOR_LIME );
	xsprintf( str, "snr2" );//xsprintf( str, "snr2   %6u", tmpfA1 );
	xn = paint_text_xy( 8, hal_paint_screen_height()-80, str );
	fd_dsp_paint_digit( xn, hal_paint_screen_height()-80, tmpfA1 );

	paint_color( COLOR_RED );
	xsprintf( str, "mul" );
	xn = paint_text_xy( 8, hal_paint_screen_height()-60, str );
	fd_dsp_paint_digit( xn, hal_paint_screen_height()-60, mul );
#else
	paint_color( COLOR_LIME );
	xsprintf( str, "snr after 1-x all    " );
	xn = paint_text_xy( 25, hal_paint_screen_height()-60, str );
	fd_dsp_paint_digit( xn, hal_paint_screen_height()-60, tmpfA0 );

	paint_color( COLOR_ORANGE );
	xsprintf( str, "snr after 2-x all    " );//xsprintf( str, "snr2   %6u", tmpfA1 );
	xn = paint_text_xy( 25, hal_paint_screen_height()-50, str );
	fd_dsp_paint_digit( xn, hal_paint_screen_height()-50, tmpfA1 );
#endif


	//get radius
	FLOAT radiusf = 0;
    for( INT i = 0; i < FD_DSP_TRAIN_DOTS; i++ ) //
	{
		FLOAT x, y;
        x = (FLOAT)line_train_x[1][i] - center_x;
		x = x * x;
        y = (FLOAT)line_train_y[1][i] - center_y;
		y = y * y;
		radiusf += sqrtf( x + y );
	}

    radiusf = radiusf / FD_DSP_TRAIN_DOTS;
	radius = radiusf;

#if BOARD_712_Lift
	paint_color( COLOR_GREEN );
	paint_circle( center_x, center_y, radius, PAINT_QUARTERS_ALL, 0 );
#endif

	paint_color( COLOR_LIME );
	xsprintf( str, "Radius  " );
	xn = paint_text_xy( 8, hal_paint_screen_height()-40, str );
	fd_dsp_paint_digit( xn, hal_paint_screen_height()-40, radius );

	// roudness computing
	FLOAT roudnessf = 0;
    for( INT i = 0; i < FD_DSP_TRAIN_DOTS; i++ )
	{
		FLOAT x, y;
        x = (FLOAT)line_train_x[1][i] - center_x;
		x = x * x;
        y = (FLOAT)line_train_y[1][i] - center_y;
		y = y * y;
		roudnessf += fabs( sqrtf( x + y ) - radiusf );
	}

	U32 roudness = roudnessf;

	paint_color( COLOR_SKY_BLUE );
	xsprintf( str, "Roudness  " );
	xn = paint_text_xy( 16, hal_paint_screen_height() - 15, str );
	fd_dsp_paint_digit( xn, hal_paint_screen_height() - 15, roudness );


	//---------- PD_DIRECTION_CALCULATION ----------

//	Y_YP = - math.sin(toRad(zxy_euler:y()));

//	X_YP = math.sin(toRad(zxy_euler:z() + 90));

//	FLOAT BearYP =  wrap360(toDeg(math.atan(X_YP , Y_YP))); //-- calculating this to know which way is up

	//--gcs:send_named_float('BearYP', BearYP + 0.0 );

//	PD_9 = rc:get_pwm(13); //-- former 9
//	PD_10 = rc:get_pwm(14); //-- former 10
//	PD_11 = rc:get_pwm(11);
//	PD_12 = rc:get_pwm(12);

	FLOAT PD_9  = pfd_data->v[0];
	FLOAT PD_10 = pfd_data->v[1];
	FLOAT PD_11 = pfd_data->v[2];
	FLOAT PD_12 = pfd_data->v[3];

	FLOAT PD_SUM = PD_9 + PD_10 + PD_11 + PD_12;

//	if( PD_SUM == 0 )//nil or tostring(PD_SUM) == "nan" )
//	{
//			PD_SUM = 0;
//	}

//	gcs:send_named_float('PD_SUM', PD_SUM + 0.0 );

	FLOAT X_PD, Y_PD;
	if( PD_SUM > 0.0 ) //~= 0 )
	{
		X_PD = ((PD_9 + PD_10) - (PD_12 + PD_11)) / PD_SUM;
		Y_PD = ((PD_9 + PD_12) - (PD_10 + PD_11)) / PD_SUM;
	}
	else
	{
		X_PD =  0.01;
		Y_PD = -0.01;
		//--gcs:send_text(0, "PD default values used")
	}

//	--gcs:send_named_float('X_PD', X_PD + 0.0 )

//	--gcs:send_named_float('Y_PD', Y_PD + 0.0 )

	// FLOAT YPsin = math.sin(toRad(BearYP));

	// FLOAT YPcos = math.cos(toRad(BearYP));

	// FLOAT Y_UD = - YPcos * Y_PD - YPsin * X_PD; //-- "+" means up "-" means down

//	--gcs:send_named_float('Y_UD', Y_UD + 0.0 )

	// FLOAT X_LR = - YPsin * Y_PD - YPcos * X_PD; //-- "+" means left "-" means right

//	--gcs:send_named_float('X_LR', X_LR + 0.0 )

//	FLOAT PD_AV_Y = Y_PD * 0.2; //PD_AV_Y * 0.80 + Y_PD * 0.2;
//
//	FLOAT PD_AV_X = X_PD * 0.2; //PD_AV_X * 0.80 + X_PD * 0.2;


//	FLOAT Y_PD_A = _abs(PD_AV_Y);
//
//	FLOAT X_PD_A = _abs(PD_AV_X);

	FLOAT Y_PD_NA = _abs(Y_PD);

	FLOAT X_PD_NA = _abs(X_PD);


	FLOAT PD_X_SM = (20.602 * Y_PD_NA * Y_PD_NA * Y_PD_NA - 11.12 * Y_PD_NA * Y_PD_NA + 7.4 * Y_PD_NA) * _sign(Y_PD);

//	FLOAT PD_X = (20.602 * Y_PD_A * Y_PD_A * Y_PD_A - 11.12 * Y_PD_A * Y_PD_A + 7.4 * Y_PD_A) * _sign(PD_AV_Y);

//	gcs:send_named_float('PD_X', PD_X + 0.0 )
//	--gcs:send_named_float('PD_Xsm', PD_X_SM + 0.0 )

	FLOAT PD_Y_SM = (20.602 * X_PD_NA * X_PD_NA * X_PD_NA - 11.12 * X_PD_NA * X_PD_NA + 7.4 * X_PD_NA) * _sign(X_PD);

//	FLOAT PD_Y = (20.602 * X_PD_A * X_PD_A * X_PD_A - 11.12 * X_PD_A * X_PD_A + 7.4 * X_PD_A) * _sign(PD_AV_X);

//	gcs:send_named_float('PD_Y', PD_Y + 0.0 )
//	--gcs:send_named_float('PD_Ysm', PD_Y_SM + 0.0 )

	//---------- END_OF_PD_DIRECTION_CALCULATION ----------
#if BOARD_712_Lift
	paint_color( COLOR_SKY_BLUE );
	xsprintf( str, "X_PD     %2.3f", X_PD );
	paint_text_xy( 350, 30, str );
	xsprintf( str, "PD_X_SM     %2.3f", PD_X_SM );
	paint_text_xy( 350, 50, str );

	paint_color( COLOR_ORANGE );
	xsprintf( str, "Y_PD     %2.3f", Y_PD);
	paint_text_xy( 350, 90, str );
	xsprintf( str, "PD_Y_SM     %2.3f", PD_Y_SM );
	paint_text_xy( 350, 110, str );
#endif
	//fd_dsp_paint_digit( xn, hal_paint_screen_height()-30, tmpfA1 ); //only snr
	//fd_dsp_paint_digit( xn, hal_paint_screen_height()-30, tmpfA0 );

//	xsprintf( str, "rssi1:" );
//	xn = paint_text_xy( 12, hal_paint_screen_height()-22, str );
//	fd_dsp_paint_digit( xn, hal_paint_screen_height()-22, tmpfA1 );

//	paint_color( COLOR_WHITE);
//	xsprintf( str, "%uFD     dft%u    vec%c",
//			pfd_settings->fd_num,
//			pfd_settings->dft_mode,
//			( pfd_settings->vector_mode == 0 ) ? '1' :
//			( pfd_settings->vector_mode == 1 ) ? 'Y' : 'P' );
//	xsprintf( str, "PID%u    dft%u   CLB%u",
//			set_PID_on,
//			pfd_settings->dft_mode, calibration );

}

void fd_dsp_draw_init( fd_data_t *pfd_data )
{
	pfd_data->fd_num = 8;
    pfd_data->buf_size = 1600;
}

void fd_dsp_add_new_vector( fd_data_t *pfd_data )
{
	static BOOL init = FALSE;

    if( init == FALSE )
    {
        init = TRUE;

        for( INT i = 0; i < FD_DSP_TRAIN_DOTS - 1; i++ )
		{
            line_train_x[0][i] = 0;
            line_train_y[0][i] = 0;
            line_train_x[1][i] = 0;
            line_train_y[1][i] = 0;
		}
    }

	// move points from worm ---------------------------------------------------
    for( INT i = 256 -1; i > 0; i-- )
	{
        line_train_x[0][i] = line_train_x[0][i-1];
        line_train_y[0][i] = line_train_y[0][i-1];
        line_train_x[1][i] = line_train_x[1][i-1];
        line_train_y[1][i] = line_train_y[1][i-1];
	}

    // copy new coordinates ----------------------------------------------------
    line_train_x[0][0] = pfd_data->fx[0] + 0;
    line_train_y[0][0] = pfd_data->fy[0] + 0;
    line_train_x[1][0] = pfd_data->fx[1] + 0;
    line_train_y[1][0] = pfd_data->fy[1] + 0;

}

INT calibrate = FD_CLB_STATE_INIT;
static U8 calibrate_state[ FD_CLB_DOTS * 2 ];

void fd_dsp_calibrate_process( fd_data_t *pfd_data, FLOAT *clb )
{
    switch( calibrate )
    {
    case FD_CLB_STATE_INIT: { //init all
        for( INT i = 0; i < FD_CLB_DOTS * 2; i++ )
        {
            calibrate_state[i] = 0;
            // calibrate_buf[i] = 1.0;
            // calibrate_angle[i] = i;
        }
        calibrate = FD_CLB_STATE_NOP;
    } break;

    case FD_CLB_STATE_RESET: {
    } break;

    case FD_CLB_STATE_AFTER_RESET: {
    } break;

    case FD_CLB_STATE_DATA_COLLECT: {
        volatile FLOAT dird;
        volatile U32 tditd;

        // test for precise
        dird = pfd_data->dir[0] * 10.;
        tditd = fabs( dird );
        tditd = tditd % 10;
        //if( tditd <= 1 || tditd >= 9 )
        {
            calibrate_state[ pfd_data->bufpos[0] ] = 1;
            clb[ pfd_data->bufpos[0] ] = 100. / pfd_data->len[0];
            //calibrate_angle[ bufpos ] = dir;
        }

        dird = pfd_data->dir[1] * 10.;
        tditd = fabs( dird );
        tditd = tditd % 10;
        //if( tditd <= 1 || tditd >= 9 )
        {
            calibrate_state[ FD_CLB_DOTS + pfd_data->bufpos[1] ] = 1;
            clb[ pfd_data->bufpos[1] ] = 100. / pfd_data->len[1];
            //calibrate_angle[ bufpos ] = dir;
        }

        // test for ready all dots
        INT all_points_ready = 0;
        INT points_ready_cnt = 0;
        for( INT i = 0; i < FD_CLB_DOTS; i++ )
        {
            if( calibrate_state[ FD_CLB_DOTS + i ] != 0 )
            {
                points_ready_cnt++;
            }
        }
        if( points_ready_cnt >= 360 )
        {
            all_points_ready = 1;
        }
        if( all_points_ready )
        {
            calibrate = FD_CLB_STATE_DATA_COLLECT_OK;
        }
    } break;

    case FD_CLB_STATE_DATA_COLLECT_OK: {
    } break;

    case FD_CLB_STATE_DATA_COLLECT_ERR: {
    } break;

    case FD_CLB_STATE_WAIT_SEND: {
        //nothin...
        //angle = wrap360( angle + 5.0f );
    } break;

    case FD_CLB_STATE_CALIBRATE_WRITE: {

    } break;

    default: break;
    }
}

void fd_dsp_draw_all( fd_data_t *pfd, fd_serial_data_t *pfsd, U32 mode, U32 filter, U32 mul )
{
    static BOOL init = FALSE;
    static COORD center_x = 800/2;
    static COORD center_y = 480/2 + 11;
	static U32 radius = 1;
    static U32 delay_cnt = 0;
    COORD yn;

    if( init == FALSE )
    {
        U32 hue;
        init = TRUE;
        for( INT i = 0; i < DSP_FD_CHANNEL_NUM; i++ )
        {
            hue = ((100 * i) / 4 );
            colors[i] = HSV_to_RGB( hue, 255, 255 );
        }
    }

	// draw x-cross ------------------------------------------------------------
	paint_color( COLOR_BLUE );
	paint_line( center_x, center_y - AREA_SIZE, center_x, center_y + AREA_SIZE );
	paint_line( center_x - AREA_SIZE, center_y, center_x + AREA_SIZE, center_y );

	// draw coord grid ---------------------------------------------------------
	paint_color( COLOR_BLUE + COLOR_GREEN );
	for( COORD j = -(AREA_SIZE); j <= AREA_SIZE; j += GRID_SIZE )
	{
		for( COORD i = -(AREA_SIZE); i <= AREA_SIZE; i += GRID_SIZE )
		{
			paint_pixel( center_x + j, center_y + i );
		}
	}

    // draw points and crosses -------------------------------------------------
    if( mode & 0x01 )
    {
        paint_color( COLOR_LIME );
        for( INT i = 0; i < FD_DSP_TRAIN_DOTS; i++ )
        {
            COORD x1 = line_train_x[0][i] + center_x;
            COORD y1 = line_train_y[0][i] + center_y;
            COORD x2 = line_train_x[0][i+1] + center_x;
            COORD y2 = line_train_y[0][i+1] + center_y;
            paint_line( x1, y1, x2, y2 );
        }
        paint_color( COLOR_LIME );
        COORD x1 = line_train_x[0][0];
        COORD y1 = line_train_y[0][0];
        fd_dsp_paint_vector( center_x, center_y, x1, y1, MARK_SIZE );
    }
    if( mode & 0x02 )
    {
        paint_color( COLOR_YELLOW );
        for( INT i = 0; i < FD_DSP_TRAIN_DOTS; i++ )
        {
            COORD x1 = line_train_x[1][i] + center_x;
            COORD y1 = line_train_y[1][i] + center_y;
            COORD x2 = line_train_x[1][i+1] + center_x;
            COORD y2 = line_train_y[1][i+1] + center_y;
            paint_line( x1, y1, x2, y2 );
        }
        paint_color( COLOR_YELLOW );
        COORD x1 = line_train_x[1][0];
        COORD y1 = line_train_y[1][0];
        fd_dsp_paint_vector( center_x, center_y, x1, y1, MARK_SIZE );
	}

    static U32 v[12];
    static U32 snr[12];

    if( delay_cnt == 0 )
	{
        for( INT i = 0; i < 8; i++ ) //DSP_FD_CHANNEL_NUM
        {
            v[i] = pfd->v[i];
        }

        for( INT i = 0; i < 8; i++ )
        {
            snr[i] = pfd->snr[i];
        }
    }

    if( mode & 0x04 ) //todo
    {
        for( INT i = 0; i < 8; i++ ) //DSP_FD_CHANNEL_NUM
        {
            paint_color( COLOR_RED );
            xsprintf( str, "SNR %1u  %8u", i + 1, v[i] );
            paint_text_xy( 8, 4 + 20 * i, str );
        }
    }
    else
    {
        for( INT i = 0; i < 4; i++ ) //DSP_FD_CHANNEL_NUM
        {
            if( mode & 0x01 )
            {
                paint_color( COLOR_LIME );
            }
            else
                paint_color( COLOR_BLACK );

            xsprintf( str, "CH %1u   %8u", i + 1, v[i] );
            paint_text_xy( 8, 2 + 20 * i, str );
        }
        for( INT i = 4; i < 8; i++ ) //DSP_FD_CHANNEL_NUM
        {
            if( mode & 0x02 )
            {
                paint_color( COLOR_YELLOW );
            }
            else
                paint_color( COLOR_BLACK );

            xsprintf( str, "CH %1u   %8u", i + 1, v[i] );
            paint_text_xy( 8, 4 + 20 * i, str );
        }
    }

    // signal to noise ratio for branches ======================================
    paint_color( COLOR_RED );
    if( snr[1] < 1000 )
    {
        paint_color( COLOR_YELLOW );
    }
    xsprintf( str, "N 1B   %8u", snr[0]);
    paint_text_xy( 610, 100, str );

    paint_color( COLOR_RED );
    if( snr[1] < 1000 )
    {
        paint_color( COLOR_LIME );
    }
    xsprintf( str, "N 2B   %8u", snr[1] );
    yn = 130;
    paint_text_xy( 610, yn, str );


    U32 bnum = 1;//mode & 0x1 ? 0 : 1;

    if( mode & 0x03 )
    {
        //get radius
        FLOAT radiusf = 0;
        for( INT i = 0; i < (FD_DSP_TRAIN_DOTS - 1); i++ )
        {
            FLOAT x, y;
            x = (FLOAT)line_train_x[ bnum ][i];
            y = (FLOAT)line_train_y[ bnum ][i];
            radiusf += sqrtf( x * x + y * y );
        }

        radiusf = radiusf / (FD_DSP_TRAIN_DOTS - 1);
        radius = radiusf;

        //radius = _constrain( radius, 0, AREA_SIZE );

        paint_color( COLOR_BLUE + COLOR_GREEN );
        paint_circle( center_x, center_y, radius, PAINT_QUARTERS_ALL, 0 );

        static U32 _radius;
        if( 0 == delay_cnt )
        {
            _radius = (FLOAT)radius;// / (FLOAT)mul;
        }

        paint_color( COLOR_SKY_BLUE );
        xsprintf( str, "RS    %6u", _radius );
        paint_text_xy( 610, 200, str );

        // roudness computing
        FLOAT roudnessf = 0;
        for( INT i = 0; i < (FD_DSP_TRAIN_DOTS - 2); i++ )
        {
            FLOAT x, y;
            x = (FLOAT)line_train_x[ bnum ][i];
            y = (FLOAT)line_train_y[ bnum ][i];
            roudnessf += fabs( sqrtf( x * x + y * y ) - radiusf );
        }

        U32 roudness = roudnessf / mul;

        static U32 _roudness;
        if( 0 == delay_cnt )
        {
            _roudness = roudness;
        }

        if( _roudness <= 50 )
            paint_color( COLOR_GOLD );
        else
            paint_color( COLOR_SKY_BLUE );

        xsprintf( str, "RNDS  %6u", _roudness );
        paint_text_xy( 610, 230, str );
    }

    // draw calibration line ===================================================
    COORD xw = ((800/2)-FD_CLB_DOTS/2);

    for( INT i = 0; i < FD_CLB_DOTS; i++ )
    {
        COLOR color = COLOR_RED;
        if( calibrate_state[ i ] != 0 )
        {
            color = COLOR_LIME;
        }
        paint_color( color );
        paint_line( xw + i, 480 - 11, xw + i, 480 - 15 );
    }
    // draw line current
    paint_color( COLOR_LIME );
    paint_line( xw + pfd->bufpos[0], 480 - 16, xw + pfd->bufpos[0], 480 - 21 );

    for( INT i = 0; i < FD_CLB_DOTS; i++ )
    {
        COLOR color = COLOR_RED;
        if( calibrate_state[ FD_CLB_DOTS + i ] != 0 )
        {
            color = COLOR_YELLOW;
        }
        paint_color( color );
        paint_line( xw + i, 480 - 1, xw + i, 480 - 5 );
    }
    // draw line current
    paint_color( COLOR_YELLOW );
    paint_line( xw + pfd->bufpos[1], 480 - 6, xw + pfd->bufpos[1], 480 - 10 );

    // polinom get =============================================================
    fd_dsp_polinom( pfd );

    static FLOAT xpd, ypd, xpdsm, ypdsm;
    if( 0 == delay_cnt )
    {
        xpd = pfd->fx[ bnum ];
        ypd = pfd->fy[ bnum ];
        xpdsm = pfd->fpx[ bnum ];
        ypdsm = pfd->fpy[ bnum ];
    }

	paint_color( COLOR_SKY_BLUE );
    xsprintf( str, "X_PD     %2.2f", xpd );
    paint_text_xy( 610, 330, str );
    xsprintf( str, "PD_X_SM  %2.2f", xpdsm );
    paint_text_xy( 610, 350, str );

    paint_color( COLOR_YELLOW );
    xsprintf( str, "Y_PD     %2.2f", ypd );
    paint_text_xy( 610, 390, str );
    xsprintf( str, "PD_Y_SM  %2.2f", ypdsm );
    paint_text_xy( 610, 410, str );

    if( ++delay_cnt > filter )
    {
        delay_cnt = 0;
    }

    //xsprintf( str, "v%u fps:%d mmc:%u", 20240407, 10, 35 ); fps, mavps, fsd.version, fsd.idnum, fsd.inc_cnt
    xsprintf( str, "v%04u id:%u c:%u", pfsd->version, pfsd->idnum, pfsd->inc_cnt );
    paint_color_set( COLOR_WHITE );
    paint_text_xy( 300, 2, str );
}

#include "modGUI.h"
button_t button_calib = { .x = 8, .y = 200, .w =  85, .h = 60, .color = COLOR_ORANGE, .color_pressed = COLOR_BLUE };
button_t button_filt = { .x = 103, .y = 200, .w =  85, .h = 60, .color = COLOR_ORANGE, .color_pressed = COLOR_BLUE };
button_t button_mode  = { .x = 8, .y = 270, .w = 180, .h = 60, .color = COLOR_ORANGE, .color_pressed = COLOR_BLUE };
button_t button_idnum  = { .x = 8, .y = 340, .w = 180, .h = 60, .color = COLOR_ORANGE, .color_pressed = COLOR_BLUE };
button_t button_mul   = { .x = 8, .y = 410, .w = 180, .h = 60, .color = COLOR_ORANGE, .color_pressed = COLOR_BLUE };

extern BOOL touch_has_signal_state;

U32 idnum = 0;

void fd_dsp_buttons_processor( U32 *mode, U32 *filter_mode, U32 *mul )
{
    static INT touched = 0;
    char str[64];
    INT button_calib_state = 0;
    INT button_mode_state = 0;
    INT button_filt_state = 0;
    INT button_idnum_state = 0;
    INT button_mul_state = 0;

    if( fd_dsp_touch_has_signal() )
    {
        if( fd_dsp_touch_touched() && !touched )
        {
            touched = 1;

            button_calib_state = fd_dsp_button_test( &button_calib );
            if( 1 == button_calib_state )
            {
                switch( calibrate )
                {
                case FD_CLB_STATE_INIT: break;
                case FD_CLB_STATE_NOP: calibrate = FD_CLB_STATE_RESET; break;
                case FD_CLB_STATE_RESET: fd_dsp_calibrate_reset(); calibrate = FD_CLB_STATE_AFTER_RESET; break;
                case FD_CLB_STATE_AFTER_RESET: calibrate = FD_CLB_STATE_DATA_COLLECT; break;
                case FD_CLB_STATE_DATA_COLLECT: break;
                case FD_CLB_STATE_DATA_COLLECT_OK: calibrate = FD_CLB_STATE_CALIBRATE_WRITE; break;
                case FD_CLB_STATE_DATA_COLLECT_ERR: calibrate = FD_CLB_STATE_INIT; break;
                //case FD_CLB_STATE_WAIT_SEND: calibrate = FD_CLB_STATE_INIT; break;
                case FD_CLB_STATE_CALIBRATE_WRITE: fd_dsp_calibrate_write(); calibrate = FD_CLB_STATE_INIT; break;
                default: break;
                }
            }

            button_filt_state = fd_dsp_button_test( &button_filt );
            if( 1 == button_filt_state )
            {
                switch( *filter_mode )
                {
                case  1: *filter_mode =  2; break;
                case  2: *filter_mode =  4; break;
                case  4: *filter_mode =  8; break;
                case  8: *filter_mode = 16; break;
                case 16: *filter_mode =  1; break;
                default: *filter_mode =  1; break;
                }
            }

            button_mode_state = fd_dsp_button_test( &button_mode );
            if( 1 == button_mode_state )
            {
                switch( *mode )
                {
                case 1: *mode = 2; break;
                case 2: *mode = 3; break;
                case 3: *mode = 4; break;
                case 4: *mode = 1; break;
                default: *mode = 1; break;
                }
            }

            button_idnum_state = fd_dsp_button_test( &button_idnum );
            if( 1 == button_idnum_state )
            {
                idnum++;
            }

            button_mul_state = fd_dsp_button_test( &button_mul );
            if( 1 == button_mul_state )
            {
                switch( *mul )
                {
                case 1: *mul = 2; break;
                case 2: *mul = 3; break;
                case 3: *mul = 5; break;
                case 5: *mul = 7; break;
                case 7: *mul = 10; break;
                case 10: *mul = 1; break;
                default: *mul = 1; break;
                }
            }
        }
        else if( fd_dsp_touch_released() )
        {
            touched = 0;
        }
    }

    xsprintf( str, "%s",
        calibrate == FD_CLB_STATE_INIT ? "CLBI" :
        calibrate == FD_CLB_STATE_NOP ? "CLBN" :
        calibrate == FD_CLB_STATE_RESET ? "CLBR" :
        calibrate == FD_CLB_STATE_AFTER_RESET ? "CLBAR" :
        calibrate == FD_CLB_STATE_DATA_COLLECT ? "CLB C" :
        calibrate == FD_CLB_STATE_DATA_COLLECT_OK ? "CLB OK" :
        calibrate == FD_CLB_STATE_DATA_COLLECT_ERR ? "CLBERR" :
        //calibrate == FD_CLB_STATE_WAIT_SEND ? "CLBWS" :
        calibrate == FD_CLB_STATE_CALIBRATE_WRITE ? "CLBWR" :
        "ERR" );
    modGUI_button_draw( &button_calib, button_calib_state, str );

    xsprintf( str, "FLT %u", *filter_mode );
    modGUI_button_draw( &button_filt, button_filt_state, str );

    xsprintf( str, "%s",
        *mode == 1 ? "1K only" :
        *mode == 2 ? "2K only" :
        *mode == 3 ? "1K+2K" :
        *mode == 4 ? "SNR" :
        "OFF" );
    modGUI_button_draw( &button_mode, button_mode_state, str );

    xsprintf( str, "id: %u", idnum );
    modGUI_button_draw( &button_idnum, button_idnum_state, str );

    xsprintf( str, "MUL * %u", *mul );
    modGUI_button_draw( &button_mul, button_mul_state, str );
}

#endif

INT fd_dsp_polinom( fd_data_t *pdf )
{
	INT ret = 0;

    for( INT i = 0; i < 2; i++ )
    {
        FLOAT X_PD, Y_PD;

        FLOAT PD_9  = pdf->v[ i*4 + 0 ];
        FLOAT PD_10 = pdf->v[ i*4 + 1 ];
        FLOAT PD_11 = pdf->v[ i*4 + 2 ];
        FLOAT PD_12 = pdf->v[ i*4 + 3 ];

        FLOAT PD_SUM = PD_9 + PD_10 + PD_11 + PD_12;

        if( PD_SUM > 0.0 ) //~= 0 )
        {
            X_PD = ((PD_9 + PD_10) - (PD_12 + PD_11)) / PD_SUM;
            Y_PD = ((PD_9 + PD_12) - (PD_10 + PD_11)) / PD_SUM;
        }
        else
        {
            X_PD =  0.01;
            Y_PD = -0.01;
            //--gcs:send_text(0, "PD default values used")
            ret = -1;
        }

        FLOAT Y_PD_NA = _abs(Y_PD);

        FLOAT X_PD_NA = _abs(X_PD);

        FLOAT PD_X_SM = (24.3168 * Y_PD_NA * Y_PD_NA * Y_PD_NA - 17.23716 * Y_PD_NA * Y_PD_NA + 11.34996 * Y_PD_NA) * _sign(Y_PD);

        FLOAT PD_Y_SM = (24.3168 * X_PD_NA * X_PD_NA * X_PD_NA - 17.23716 * X_PD_NA * X_PD_NA + 11.34996 * X_PD_NA) * _sign(X_PD);

        pdf->fx[i] = X_PD_NA;
        pdf->fy[i] = Y_PD_NA;

        pdf->fpx[i] = PD_X_SM;
        pdf->fpy[i] = PD_Y_SM;
    }

	return ret;
}

#ifndef UART_PROTOCOL_MAVLINK

INT fd_dsp_tx_packet( U8 *buf, fd_data_t *pfd, U8 calibrated )
{
    INT i, size = 0;
    U32 n = 0;

    fd_serial_data_t *pfsd = (fd_serial_data_t *)&buf[0];

    pfsd->version = BUILD_MONTH * 100 + BUILD_DAY;
    pfsd->calibrated = calibrated;
    pfsd->error_code = RET_OK;
    pfsd->ch_num = DSP_FD_CHANNEL_NUM;
    pfsd->branches_num = 2;
    pfsd->vector_mode = 0;
    pfsd->inc_cnt = pfsd->inc_cnt + 1;

    size = 4;
    n = 4;
    U16 *pv = (U16 *)&buf[n]; //4-th byte

    for( i = 0; i < pfsd->ch_num; i++ )
    {
        pv[ i ] = _constrain( pfd->v[ i + 4 ], 0, 65535 );
        size += sizeof(U16);
        n += sizeof(U16);
    }

    for( i = 0; i < pfsd->ch_num; i++ )
    {
        pv[ i + 4 ] = _constrain( pfd->v[ i ], 0, 65535 );
        size += sizeof(U16);
        n += sizeof(U16);
    }

    U16 *psnr = (U16 *)&buf[n];
    for( i = 0; i < pfsd->ch_num * pfsd->branches_num; i++ )
    {
        psnr[i] = _constrain( pfd->snr[ i ], 0, 65535 );
        size += sizeof(U16);
        n += sizeof(U16);
    }

    //fd_dsp_polinom( pfd ); // after calibration - signal coordinates

    //    FLOAT *pfx = (FLOAT *)&buf[n];
    //    for( i = 0; i < 2; i++ )
    //    {
    //        pfx[i] = pfd->fx[ i ];
    //        size += sizeof(FLOAT);
    //        n += sizeof(FLOAT);
    //    }
    //
    //    FLOAT *pfy = (FLOAT *)&buf[n];
    //    for( i = 0; i < 2; i++ )
    //    {
    //        pfy[i] = pfd->fy[ i ];
    //        size += sizeof(FLOAT);
    //        n += sizeof(FLOAT);
    //    }

    return size;
}

INT fd_dsp_rx_packet( U8 *buf, fd_serial_data_t *pfsd, fd_data_t *pfd )
{
	INT i, ret = 0;
	U32 n = 0;
	static U8 inc_cnt = 0;
	INT size = 0;

	fd_serial_data_t *pfsdl = (fd_serial_data_t*)&buf[0];

	*pfsd = *pfsdl;

	if( RET_OK != pfsd->error_code )
	{
		ret = 1;
	}

	if( 0 == pfsd->ch_num )
	{
		ret = 1;
	}

	if( 0 == pfsd->branches_num )
	{
		ret = 1;
	}

	// test for increment number
	if(( pfsd->inc_cnt - 1 ) != inc_cnt )
	{
        //ret = 1;
	}
	inc_cnt = pfsd->inc_cnt;

	size = 4;
	n = 4;
    U16 *pv = (U16 *)&buf[n]; //4-th byte

	for( i = 0; i < pfsd->ch_num * pfsd->branches_num; i++ )
	{
        pfd->v[ i ] = pv[ i ];
        size += sizeof(U16);
		n += sizeof(U16);
	}

    U16 *psnr = (U16 *)&buf[n];
    for( i = 0; i < pfsd->ch_num * pfsd->branches_num; i++ )
	{
        pfd->snr[ i ] = psnr[ i ];
        size += sizeof(U16);
		n += sizeof(U16);
	}

//    FLOAT *pFx = (FLOAT *)&buf[n];
//    for( i = 0; i < 2; i++ )
//    {
//        pfd->fpx[i] = pFx[0];
//        size += sizeof(FLOAT);
//        n += sizeof(FLOAT);
//    }
//
//    FLOAT *pFy = (FLOAT *)&buf[n];
//    for( i = 0; i < 2; i++ )
//    {
//        pfd->fpy[i] = pFy[0];
//        size += sizeof(FLOAT);
//        n += sizeof(FLOAT);
//    }

	return ret;
}

#else

INT fd_dsp_calibrate_tx_packet( U8 *buf, fd_data_t *pfd, U8 calibrated )
{
    INT i, size = 0;
    U32 n = 0;

    fd_serial_data_t *pfsd = (fd_serial_data_t *)&buf[0];

    pfsd->version = BUILD_MONTH * 100 + BUILD_DAY;
    pfsd->calibrated = calibrated;
    pfsd->error_code = RET_OK;
    pfsd->ch_num = DSP_FD_CHANNEL_NUM;
    pfsd->branches_num = 2;
    pfsd->vector_mode = 0;
    pfsd->inc_cnt = pfsd->inc_cnt + 1;

    size = 4;
    n = 4;
    U16 *pv = (U16 *)&buf[n]; //4-th byte

    for( i = 0; i < pfsd->ch_num; i++ )
    {
        pv[ i ] = _constrain( pfd->v[ i + 4 ], 0, 65535 );
        size += sizeof(U16);
        n += sizeof(U16);
    }

    return size;
}

#endif



void fd_dsp_test( void )
{
    //16KHz sempl
    static const U16 ADC_buf[ 1502 ]  = { 2018, 2075, 2075, 2072, 2069, 2066, 2023, 2022, 2024, 2026, 2028, 2028, 2028, 2047, 2079, 2077, 2073, 2070, 2066, 2023, 2021, 2023, 2025, 2025, 2027, 2029, 2031, 2085, 2076, 2073, 2069, 2068, 2033, 2021, 2024, 2024, 2026, 2026, 2028, 2029, 2089, 2077, 2073, 2070, 2068, 2065, 2024, 2024, 2022, 2026, 2027, 2029, 2029, 2084, 2080, 2074, 2070, 2069, 2065, 2023, 2022, 2025, 2025, 2026, 2027, 2029, 2061, 2080, 2074, 2072, 2071, 2066, 2023, 2022, 2021, 2024, 2026, 2027, 2029, 2033, 2083, 2078, 2073, 2071, 2070, 2028, 2022, 2021, 2023, 2026, 2027, 2027, 2029, 2087, 2077, 2072, 2070, 2067, 2053, 2022, 2022, 2024, 2026, 2026, 2027, 2029, 2085, 2077, 2074, 2071, 2065, 2065, 2021, 2023, 2024, 2025, 2026, 2028, 2029, 2066, 2079, 2075, 2071, 2067, 2068, 2022, 2021, 2024, 2025, 2027, 2027, 2031, 2038, 2081, 2078, 2072, 2071, 2067, 2025, 2021, 2023, 2025, 2025, 2026, 2027, 2030, 2085, 2076, 2072, 2069, 2068, 2040, 2019, 2023, 2023, 2025, 2027, 2027, 2029, 2085, 2079, 2075, 2069, 2069, 2066, 2021, 2022, 2023, 2026, 2027, 2028, 2029, 2074, 2081, 2075, 2072, 2069, 2066, 2021, 2023, 2024, 2025, 2026, 2028, 2027, 2047, 2081, 2076, 2072, 2070, 2065, 2024, 2021, 2023, 2025, 2026, 2025, 2028, 2031, 2083, 2075, 2075, 2071, 2068, 2033, 2021, 2023, 2023, 2025, 2027, 2028, 2029, 2090, 2077, 2075, 2068, 2067, 2063, 2021, 2022, 2023, 2024, 2027, 2028, 2029, 2083, 2077, 2075, 2070, 2068, 2064, 2021, 2021, 2023, 2025, 2027, 2028, 2029, 2055, 2080, 2076, 2072, 2069, 2066, 2022, 2021, 2023, 2024, 2025, 2027, 2028, 2035, 2084, 2077, 2072, 2069, 2067, 2029, 2022, 2022, 2026, 2025, 2026, 2027, 2029, 2090, 2077, 2073, 2068, 2067, 2056, 2021, 2023, 2024, 2025, 2026, 2028, 2028, 2086, 2078, 2075, 2071, 2067, 2068, 2022, 2022, 2025, 2025, 2028, 2027, 2029, 2065, 2078, 2076, 2071, 2068, 2067, 2023, 2021, 2024, 2023, 2026, 2027, 2028, 2037, 2083, 2076, 2073, 2070, 2066, 2026, 2022, 2024, 2025, 2025, 2028, 2028, 2029, 2087, 2075, 2073, 2071, 2069, 2041, 2022, 2022, 2025, 2024, 2026, 2029, 2029, 2089, 2078, 2074, 2073, 2068, 2065, 2023, 2021, 2024, 2026, 2026, 2028, 2029, 2075, 2079, 2076, 2071, 2070, 2067, 2023, 2022, 2023, 2025, 2027, 2027, 2028, 2048, 2080, 2074, 2073, 2069, 2068, 2023, 2021, 2022, 2025, 2025, 2027, 2029, 2031, 2085, 2076, 2074, 2070, 2068, 2034, 2022, 2023, 2023, 2025, 2025, 2029, 2029, 2091, 2078, 2073, 2071, 2068, 2062, 2022, 2022, 2024, 2026, 2025, 2027, 2028, 2079, 2078, 2074, 2071, 2069, 2065, 2021, 2022, 2022, 2024, 2024, 2027, 2029, 2055, 2080, 2075, 2071, 2069, 2065, 2023, 2022, 2024, 2025, 2026, 2026, 2028, 2034, 2082, 2077, 2073, 2072, 2066, 2028, 2021, 2022, 2025, 2026, 2027, 2028, 2030, 2089, 2079, 2074, 2071, 2067, 2053, 2021, 2022, 2024, 2025, 2025, 2027, 2029, 2088, 2078, 2074, 2070, 2068, 2065, 2019, 2023, 2021, 2025, 2026, 2027, 2029, 2065, 2079, 2075, 2073, 2069, 2066, 2022, 2023, 2023, 2025, 2027, 2025, 2028, 2038, 2081, 2075, 2073, 2069, 2067, 2026, 2022, 2023, 2025, 2026, 2026, 2028, 2030, 2087, 2077, 2071, 2069, 2069, 2039, 2021, 2023, 2024, 2025, 2027, 2027, 2029, 2087, 2078, 2074, 2071, 2068, 2064, 2021, 2023, 2023, 2025, 2027, 2027, 2029, 2074, 2077, 2078, 2073, 2068, 2066, 2021, 2021, 2022, 2024, 2025, 2027, 2029, 2047, 2081, 2077, 2072, 2071, 2068, 2025, 2021, 2023, 2025, 2026, 2026, 2027, 2030, 2084, 2077, 2074, 2072, 2068, 2033, 2021, 2023, 2024, 2026, 2028, 2028, 2029, 2092, 2077, 2075, 2069, 2067, 2064, 2021, 2023, 2023, 2026, 2029, 2027, 2029, 2081, 2077, 2076, 2071, 2068, 2065, 2021, 2021, 2025, 2025, 2026, 2027, 2030, 2058, 2080, 2077, 2072, 2069, 2065, 2022, 2021, 2021, 2023, 2026, 2027, 2027, 2032, 2082, 2077, 2073, 2070, 2066, 2029, 2021, 2023, 2025, 2025, 2027, 2029, 2029, 2089, 2077, 2074, 2070, 2068, 2054, 2022, 2021, 2024, 2025, 2026, 2028, 2030, 2088, 2077, 2075, 2074, 2068, 2065, 2021, 2022, 2023, 2025, 2025, 2027, 2029, 2065, 2080, 2073, 2071, 2067, 2065, 2023, 2021, 2024, 2023, 2027, 2028, 2029, 2038, 2082, 2073, 2073, 2070, 2066, 2025, 2021, 2021, 2025, 2025, 2026, 2027, 2028, 2087, 2078, 2072, 2068, 2067, 2040, 2022, 2021, 2024, 2024, 2026, 2027, 2029, 2088, 2077, 2073, 2071, 2068, 2067, 2021, 2021, 2023, 2026, 2026, 2028, 2028, 2076, 2078, 2075, 2073, 2069, 2066, 2023, 2021, 2024, 2025, 2027, 2027, 2028, 2045, 2081, 2076, 2073, 2069, 2067, 2025, 2022, 2023, 2024, 2025, 2027, 2029, 2031, 2087, 2076, 2073, 2069, 2065, 2033, 2022, 2024, 2025, 2026, 2026, 2027, 2028, 2090, 2078, 2073, 2070, 2068, 2066, 2023, 2021, 2023, 2026, 2026, 2028, 2030, 2084, 2078, 2076, 2072, 2070, 2067, 2021, 2022, 2023, 2023, 2025, 2026, 2029, 2052, 2080, 2073, 2073, 2069, 2068, 2023, 2019, 2023, 2023, 2025, 2027, 2029, 2033, 2083, 2075, 2073, 2068, 2067, 2028, 2021, 2024, 2023, 2025, 2027, 2028, 2029, 2089, 2075, 2074, 2073, 2067, 2053, 2022, 2023, 2023, 2026, 2026, 2027, 2029, 2087, 2077, 2075, 2070, 2067, 2067, 2023, 2021, 2025, 2025, 2026, 2027, 2028, 2063, 2079, 2076, 2072, 2067, 2068, 2021, 2023, 2023, 2025, 2026, 2026, 2028, 2039, 2084, 2075, 2073, 2069, 2066, 2026, 2021, 2021, 2025, 2026, 2027, 2027, 2031, 2086, 2077, 2072, 2067, 2066, 2041, 2021, 2022, 2023, 2023, 2026, 2027, 2027, 2086, 2077, 2075, 2069, 2069, 2064, 2021, 2023, 2024, 2024, 2025, 2028, 2029, 2074, 2079, 2076, 2071, 2067, 2063, 2022, 2022, 2024, 2025, 2026, 2026, 2029, 2043, 2083, 2075, 2074, 2069, 2068, 2024, 2021, 2024, 2023, 2025, 2027, 2027, 2029, 2086, 2077, 2073, 2069, 2067, 2035, 2021, 2023, 2026, 2026, 2027, 2028, 2030, 2090, 2077, 2075, 2069, 2068, 2065, 2021, 2022, 2025, 2026, 2027, 2027, 2029, 2081, 2078, 2075, 2070, 2068, 2066, 2021, 2021, 2024, 2025, 2027, 2028, 2029, 2054, 2081, 2075, 2073, 2071, 2065, 2023, 2021, 2024, 2025, 2025, 2026, 2028, 2033, 2084, 2077, 2073, 2071, 2069, 2027, 2023, 2022, 2025, 2025, 2026, 2027, 2027, 2088, 2077, 2074, 2070, 2067, 2055, 2021, 2021, 2025, 2026, 2026, 2029, 2029, 2086, 2077, 2075, 2073, 2067, 2065, 2022, 2023, 2024, 2025, 2025, 2028, 2028, 2067, 2078, 2080, 2070, 2069, 2066, 2023, 2022, 2024, 2024, 2027, 2027, 2029, 2037, 2082, 2077, 2074, 2069, 2067, 2025, 2021, 2021, 2024, 2025, 2027, 2028, 2031, 2086, 2077, 2073, 2070, 2068, 2042, 2021, 2021, 2023, 2026, 2027, 2027, 2029, 2090, 2076, 2073, 2071, 2069, 2065, 2021, 2022, 2024, 2025, 2025, 2027, 2027, 2074, 2078, 2074, 2072, 2068, 2064, 2023, 2023, 2021, 2026, 2026, 2027, 2028, 2043, 2080, 2077, 2073, 2070, 2067, 2023, 2022, 2023, 2025, 2026, 2027, 2029, 2031, 2087, 2078, 2074, 2070, 2067, 2033, 2023, 2023, 2024, 2026, 2027, 2028, 2029, 2089, 2075, 2075, 2072, 2068, 2066, 2021, 2023, 2024, 2025, 2027, 2028, 2030, 2081, 2078, 2074, 2071, 2067, 2064, 2024, 2023, 2024, 2025, 2025, 2027, 2029, 2053, 2081, 2076, 2073, 2070, 2066, 2022, 2022, 2023, 2026, 2025, 2027, 2027, 2033, 2081, 2074, 2073, 2069, 2068, 2029, 2022, 2022, 2023, 2025, 2027, 2028, 2029, 2090, 2078, 2073, 2069, 2069, 2056, 2023, 2023, 2025, 2026, 2026, 2029, 2029, 2090, 2075, 2075, 2071, 2068, 2066, 2021, 2022, 2023, 2026, 2028, 2027, 2029, 2066, 2077, 2075, 2071, 2069, 2067, 2023, 2022, 2023, 2025, 2024, 2028, 2028, 2036, 2081, 2078, 2072, 2071, 2066, 2026, 2021, 2023, 2024, 2026, 2025, 2025, 2030, 2087, 2080, 2076, 2070, 2067, 2042, 2021, 2022, 2026, 2026, 2025, 2027, 2028, 2089, 2077, 2072, 2069, 2067, 2066, 2021, 2023, 2022, 2025, 2027, 2027, 2028, 2073, 2080, 2075, 2071, 2068, 2065, 2023, 2021, 2023, 2025, 2025, 2027, 2029, 2042, 2081, 2074, 2071, 2067, 2066, 2025, 2021, 2022, 2025, 2025, 2026, 2027, 2030, 2085, 2077, 2074, 2070, 2067, 2034, 2022, 2024, 2023, 2025, 2025, 2028, 2030, 2090, 2080, 2075, 2070, 2069, 2068, 2022, 2023, 2023, 2026, 2026, 2027, 2029, 2081, 2076, 2074, 2072, 2069, 2067, 2021, 2023, 2023, 2026, 2026, 2029, 2030, 2054, 2081, 2077, 2072, 2068, 2066, 2022, 2021, 2023, 2024, 2025, 2027, 2030, 2034, 2082, 2077, 2072, 2069, 2067, 2030, 2021, 2023, 2023, 2025, 2027, 2027, 2029, 2089, 2078, 2074, 2069, 2068, 2057, 2021, 2023, 2023, 2026, 2026, 2028, 2029, 2086, 2080, 2073, 2071, 2069, 2065, 2021, 2022, 2023, 2025, 2025, 2027, 2028, 2069, 2079, 2076, 2071, 2071, 2066, 2022, 2022, 2023, 2025, 2026, 2027, 2029, 2039, 2082, 2076, 2073, 2070, 2069, 2026, 2022, 2021, 2024, 2026, 2026, 2028, 2029, 2086, 2079, 2073, 2070, 2066, 2043, 2022, 2023, 2025, 2025, 2025, 2027, 2028, 2090, 2077, 2074, 2072, 2069, 2065, 2022, 2021, 2026, 2025, 2027, 2027, 2029, 2073, 2078, 2075, 2072, 2068, 2066, 2021, 2021, 2023, 2026, 2025, 2027, 2028, 2046, 2082, 2075, 2070, 2068, 2067, 2025, 2021, 2022, 2023, 2027, 2027, 2027, 2030, 2085, 2078, 2073, 2070, 2067, 2034, 2022, 2023, 2025, 2027, 2026, 2027, 2029, 2087, 2076, 2075, 2071, 2068, 2065, 2022, 2023, 2023, 2026, 2027, 2027, 2029, 2082, 2080, 2075, 2072, 2069, 2065, 2022, 2022, 2023, 2025, 2025, 2028, 2027, 2053, 2081, 2076, 2072, 2070, 2065, 2025, 2023, 2025, 2025, 2025, 2026, 2027, 2033, 2084, 2078, 2075, 2070, 2067, 2029, 2022, 2023, 2024, 2026, 2027, 2027, 2030, 2090, 2079, 2073, 2069, 2067, 2056, 2022, 2021, 2024, 2025, 2025, 2028, 2029, 2086, 2077, 2076, 2070, 2068, 2068, 2021, 2022, 2023, 2025, 2025, 2027, 2027, 2064, 2077, 2075, 2072, 2048 };

    fd_data_t fd_data;
    U32 tic;
    S32 tmpS32;

#ifdef STM32
    __disable_irq();
#endif

    //dc remove filter init

    //	fd_settings.fd_num = 3;
    //	fd_settings.dft_mode = 1;
    //	fd_settings.vector_mode = 1;
    //	fd_settings.buf_size = 1500;

    fd_dsp_frq_set( 0, 1209.0 );
    fd_dsp_sample_rate_set( 16000 );//DSP_FD_SAMPLING_RATE );
    fd_dsp_buf_size_set( 500 );//DSP_FD_BUF_SIZE );
    //fd_dsp_mashtab_set( 6 );
    fd_dsp_init(); //init


    for( INT i = 0; i < 5; i++ )
    {
        RESET_CORE_COUNT;
        fd_dsp_process_v1( (U16*)&ADC_buf[0], &fd_data );
        tic = GET_CORE_COUNT;

        //		RESET_CORE_COUNT;
        //		dsp_fd_process_v3( (U16*)&ADC_buf[0], &fd_level );
        //		tic = GET_CORE_COUNT;

        //test_param( fd_level.v[0][0] < 5 );//!= 495 );

        RESET_CORE_COUNT;
        fd_dsp_vector_get( &fd_data, 100 );
        tic = GET_CORE_COUNT;
    }
    (void)tic;

#ifdef STM32
    __enable_irq();
#endif
}
