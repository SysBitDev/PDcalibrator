# Бібліотека DEBUG

## Опис

Бібліотека DEBUG забезпечує інструменти для налагодження та вимірювання продуктивності коду на мікроконтролерах STM32. Вона дозволяє ініціалізувати й використовувати внутрішній цикл таймера (Core Cycle Counter), відстежувати статус налагодження та виводити діагностичну інформацію за допомогою користувацьких функцій.

Бібліотека також підтримує відладку через SWO (Serial Wire Output) та налаштування додаткових діагностичних функцій.

---

## Функціонал

- **Ініціалізація відладки:**
  - Включення Core Cycle Counter для вимірювання часу виконання.
  - Включення SWO (Serial Wire Output) для текстового виводу.
- **Засоби діагностики:**
  - Перевірка режиму налагодження (`debug_mode_get`).
  - Виведення повідомлень через функції `debug_printf` та `debug_put`.
- **Вимірювання продуктивності:**
  - Макроси `RESET_CORE_COUNT` та `GET_CORE_COUNT` для роботи з Core Cycle Counter.

---

## Інтеграція

1. **Підключення бібліотеки:**
   - Додайте файли `_debug.h` та `_debug.c` у свій проєкт.
   - Підключіть бібліотеку у вашому коді:
     ```c
     #include "_debug.h"
     ```

2. **Вимоги:**
   - Підтримуються STM32 з архітектурою Cortex-M (з Core Cycle Counter).
   - Увімкнення макросів налагодження через компілятор:
     ```c
     #define __DEBUG 1
     ```

---

## Приклади використання

### 1. Ініціалізація налагодження

Для використання можливостей бібліотеки необхідно ініціалізувати її викликом функції `_debug_init`.

```c
#include "_debug.h"

int main() {
    _debug_init(); // Ініціалізація відладки

    if (debug_mode_get()) {
        debug_printf("Режим налагодження увімкнено.\n");
    } else {
        debug_printf("Режим налагодження вимкнено.\n");
    }

    return 0;
}
```

---

### 2. Вимірювання часу виконання

За допомогою Core Cycle Counter можна виміряти кількість тактів виконання певного коду.

```c
#include "_debug.h"

int main() {
    U32 start, end;

    _debug_init(); // Ініціалізація відладки

    RESET_CORE_COUNT; // Скидання лічильника
    start = GET_CORE_COUNT; // Початкове значення

    // Код для вимірювання
    for (volatile int i = 0; i < 1000000; i++);

    end = GET_CORE_COUNT; // Кінцеве значення
    debug_printf("Час виконання: %lu тактів\n", end - start);

    return 0;
}
```

---

### 3. Виведення діагностичної інформації

Функція `debug_printf` дозволяє виводити діагностичну інформацію у зручному форматі.

```c
#include "_debug.h"

int main() {
    _debug_init(); // Ініціалізація відладки

    int value = 42;
    debug_printf("Значення змінної: %d\n", value);

    return 0;
}
```

---

### 4. SWO (Serial Wire Output)

Бібліотека підтримує налаштування SWO для відладки через TRACE.

```c
#include "_debug.h"

int main() {
    _debug_init(); // Ініціалізація відладки із включенням SWO
    debug_printf("Вивід через SWO увімкнено.\n");

    return 0;
}
```

---

### 5. Обробка HardFault

Бібліотека включає функцію для обробки HardFault, що дозволяє отримувати інформацію про стан регістрів під час помилки.

```c
#include "_debug.h"

void HardFault_Handler(void) {
    debug_printf("HardFault оброблено!\n");
    while (1);
}
```

---

## Макроси

- `RESET_CORE_COUNT` – скидає значення Core Cycle Counter.
- `GET_CORE_COUNT` – отримує поточне значення Core Cycle Counter.

---

## Структура бібліотеки

1. **Функції ініціалізації:**
   - `_debug_init()` – ініціалізує Core Cycle Counter, SWO та додаткові відладочні можливості.
   - `debug_cnt_init()` – включає Core Cycle Counter для STM32.

2. **Функції налагодження:**
   - `debug_printf(const char *fmt, ...)` – форматований текстовий вивід.
   - `debug_put(const char *p)` – вивід текстового рядка.

3. **Функції діагностики:**
   - `debug_mode_get()` – перевіряє, чи знаходиться контролер у режимі налагодження.

---